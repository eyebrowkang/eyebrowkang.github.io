[{"content":"由于有时候会在不同的主机上修改我的一些 GitHub 仓库代码，这些代码大多是一些配置文件，比如各种 dotfile，每次增加一台新机器就需要重新设置一遍，因此在此记录一下配置步骤，后续考虑尽可能集成到一个脚本中。以下内容并不适用 Windows 系统。\nSSH 相关配置 首先来配置 ssh，虽然这不是唯一的推送方式，但是在一台较为常用且安全性得到保障（没有暴露在公网）的机器上，我认为还是 SSH 配置更好一些，可以免去每次粘贴一大段 token 的必要，接下来的部分主要都参考自 GitHub 的官方文档。\n生成 SSH 密钥 这里用到的命令是ssh-keygen，如果你的系统没有这个命令，那么访问这里来查看并安装对应的包。你可以通过man ssh-keygen查看该命令的详细手册，在其诸多选项中，此处只会用到 -t 选项，这决定了生成密钥使用的算法。 打开终端，在命令行输入ssh-keygen -t ed25519，然后会得到类似这样的输出：\nGenerating public/private ed25519 key pair. Enter file in which to save the key (/root/.ssh/id_ed25519): 这是在让我们选择密钥的保存位置，如果这是第一次生成，那么直接回车即可，接着会出现以下内容：\nEnter passphrase (empty for no passphrase): 这是让我们为此密钥设置一个密码，设置完成之后按回车，或者直接按回车代表不设置密码，然后重复密码并回车，一个密钥就生成了。这个命令的整体输出类似这样：\n➜ ~ ssh-keygen -t ed25519 Generating public/private ed25519 key pair. Enter file in which to save the key (/root/.ssh/id_ed25519): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_ed25519 Your public key has been saved in /root/.ssh/id_ed25519.pub The key fingerprint is: SHA256:9T+8qnJrytq3BntQ/Ad9ufyGimAuYNUqux3SceXkP3Q root@VM-16-7-debian The key\u0026#39;s randomart image is: +--[ED25519 256]--+ | | | | | . .+ . .| | . .*o.. ...| | ...S.o.o.E..| | +..oo o.+.o | | ..+o o+ o.+..| | .o.*o.*. ..oo| | ..oo=O=+oo.. | +----[SHA256]-----+ 在这次操作中，我们得到了两个文件，id_ed25519.pub是公钥，id_ed25519是私钥，其中公钥会上传到 GitHub 上，私钥则保存在本地，且要注意谨防泄露。\n添加 SSH 公钥至 GitHub 登录 GitHub 之后访问Add new SSH keys页面，会看到一个表单，我们只需要设置 Title 和 Key 两个字段的值即可，Title 可以随意填写，建议填写当前机器的主机名。然后我们先返回到终端，根据前面命令的输出结果找到公钥的完整路径，通过cat命令将公钥打印在终端中，对于我上面的输出结果而言，我应该执行cat /root/.ssh/id_ed25519.pub命令，其完整内容类似这样：\n➜ ~ cat /root/.ssh/id_ed25519.pub ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIH6/vsvmVi2MHq7duEZJ+Fv6FAZGG6dTZkPQWXKcRwId root@VM-16-7-debian 将该命令的输出结果复制并粘贴至 GitHub 页面的 Key 字段处，然后点击Add SSH Key按钮确认，页面会提示添加成功。\nSSH 配置文件 接下来，我们要在本地配置私钥，以便在连接 GitHub 时能够完成认证。进入家目录下的.ssh文件夹，此时该目录下应该只有两个文件，即前面生成的公钥和私钥，我们创建一个config文件，然后将下面这段内容粘贴到config文件中：\nHost github.com Hostname ssh.github.com User eyebrowkang Port 443 PreferredAuthentications publickey IdentityFile ~/.ssh/id_ed25519 你需要修改 User 之后的用户名为自己的用户名，然后保存并退出。 这是 ssh 的配置文件，可以通过man ssh_config命令查看具体的手册内容，其中详细解释了每个字段是什么意思，以及可以填哪些值，在此不做赘述。\n验证 SSH 是否绑定成功 理论上来说，已经能够成功地通过 SSH 访问 GitHub 了，我们可以通过ssh -T git@github.com来验证，首次输入会得到这样的一个输出：\n➜ ~ ssh -T git@github.com The authenticity of host \u0026#39;[ssh.github.com]:443 ([20.205.243.160]:443)\u0026#39; can\u0026#39;t be established. ED25519 key fingerprint is SHA256:+DiF5lqwHfHwaSabpZisF/zLDA0zPMSvHdkr4UvCOqU. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])? 输入yes并回车，然后你应该得到这样的输出结果：\nWarning: Permanently added \u0026#39;[ssh.github.com]:443\u0026#39; (ED25519) to the list of known hosts. Hi eyebrowkang! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 这就代表设置成功了。\nSSH 密钥对的其他用处 前面生成的密钥对，除了可以用于 GitHub 还可以用于 SSH 连接服务器或者其他的 git 服务，比如 GitLab 等，你不必为每一个 SSH 服务都生成一个密钥对，当然你也可以生成，这全凭个人喜好。需要注意的是，任何时候，你都不需要将私钥上传到这些服务平台上，甚至于你完全不需要知道私钥文件的内容是什么。如果这对密钥绑定了很多的平台，比如各种 git 服务，各种云服务器，那么你一定需要备份它们，可以直接将文件复制到 U 盘中，最好不要放在各类云盘中。下面要讲到的 GPG key 的备份也是同样的道理。\nGPG Key 相关配置 GPG Key 有两个作用：加密和签名，在 GitHub 中我们只需要其签名的功能即可。具体体现在 GitHub 网站的 commit 记录上会有一个Verfied的绿色标志，这在多人协作的开源项目中比较重要，可以避免他人伪造成员的姓名和邮箱来提交，个人的项目实际上是无所谓的。 如果没有 gpg 命令，那么访问这里来安装对应的包。同样的，这是 GitHub 官方配置文档，下述内容大多参考自此文档。\n生成 GPG Key 打开终端，输入gpg --full-generate-key命令，会得到一份类似这样的输出：\ngpg (GnuPG) 2.2.27; Copyright (C) 2021 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. gpg: directory \u0026#39;/root/.gnupg\u0026#39; created gpg: keybox \u0026#39;/root/.gnupg/pubring.kbx\u0026#39; created Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card Your selection? 如果你计划这个密钥只用于签名并不用于加密数据，那么建议输入 4，否则建议保持默认，直接回车，接着需要选择密钥长度：\nRSA keys may be between 1024 and 4096 bits long. What keysize do you want? (3072) 这里根据个人喜好输入即可，我倾向于直接输入 4096，然后需要设置过期时间：\nRequested keysize is 4096 bits Please specify how long the key should be valid. 0 = key does not expire \u0026lt;n\u0026gt; = key expires in n days \u0026lt;n\u0026gt;w = key expires in n weeks \u0026lt;n\u0026gt;m = key expires in n months \u0026lt;n\u0026gt;y = key expires in n years Key is valid for? (0) 我直接输入 0，代表永远不过期，并回车。然后再次确认：\nKey does not expire at all Is this correct? (y/N) 输入 y 并回车，接着需要填写真实名字，邮箱地址，和评论三个字段，虽然实际上这里是可以随意填写的，但是由于目的是配置 GitHub，因此建议Real name填写 GitHub 的用户名，Email address使用 GitHub 的noreply 邮箱，评论随意，类似如下的效果：\nGnuPG needs to construct a user ID to identify your key. Real name: eyebrowkang Email address: 48169104+eyebrowkang@users.noreply.github.com Comment: 除此之外，还需要设置密码，此处的密码建议输入，后续导出和销毁都要用，然后输出如下：\nYou selected this USER-ID: \u0026#34;eyebrowkang \u0026lt;48169104+eyebrowkang@users.noreply.github.com\u0026gt;\u0026#34; Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? 输入O确认，接着会得到一段这样的文字：\nWe need to generate a lot of random bytes. It is a good idea to perform some other action (type on the keyboard, move the mouse, utilize the disks) during the prime generation; this gives the random number generator a better chance to gain enough entropy. 其目的是更好地生成一些随机的字节，这个时间应该很短，可以晃晃鼠标，按两下键盘，或者什么都不做也可以，然后就会得到这样的输出：\ngpg: /root/.gnupg/trustdb.gpg: trustdb created gpg: key DCA603FF70CDCDD0 marked as ultimately trusted gpg: directory \u0026#39;/root/.gnupg/openpgp-revocs.d\u0026#39; created gpg: revocation certificate stored as \u0026#39;/root/.gnupg/openpgp-revocs.d/B1D32AD243FEFF42CCEBF9A9DCA603FF70CDCDD0.rev\u0026#39; public and secret key created and signed. pub rsa4096 2023-06-03 [SC] B1D32AD243FEFF42CCEBF9A9DCA603FF70CDCDD0 uid eyebrowkang \u0026lt;48169104+eyebrowkang@users.noreply.github.com\u0026gt; sub rsa4096 2023-06-03 [E] 这就代表成功了。\n添加至 GitHub 首先需要获取密钥的 ID，输入gpg --list-secret-keys --keyid-format LONG，得到如下输出：\ngpg: checking the trustdb gpg: marginals needed: 3 completes needed: 1 trust model: pgp gpg: depth: 0 valid: 1 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 1u /root/.gnupg/pubring.kbx ------------------------ sec rsa4096/DCA603FF70CDCDD0 2023-06-03 [SC] B1D32AD243FEFF42CCEBF9A9DCA603FF70CDCDD0 uid [ultimate] eyebrowkang \u0026lt;48169104+eyebrowkang@users.noreply.github.com\u0026gt; ssb rsa4096/57D615B2EC5D45C1 2023-06-03 [E] 其中 sec 字段代表这是主密钥，ssb 代表这是子密钥。此处我们需要使用主密钥，输入gpg --armor --export DCA603FF70CDCDD0命令，会得到一长串的输出，这是主密钥的公钥部分，如下所示(有截断)：\n-----BEGIN PGP PUBLIC KEY BLOCK----- mQINBGR6/6IBEADatsJbClB2bzL/egH3MBnFHriC1Pht2oextY5ccRnt2ILoQ03w ... ... ... EpY+XBZcPygWCl4gU2BS/PuDUYidFDo= =N2E3 -----END PGP PUBLIC KEY BLOCK----- 将这部分内容完整的复制下来，然后访问GPG Key 的添加页面，粘贴到 Key 字段输入框中，Title 字段随意输入，和 SSH Key 一样，建议为当前主机名，然后确认，提示成功添加即可。\n设置 git 提交签名 GPG Key 的作用是体现在 git commit 时的，也就是即便是一个本地的 git 仓库，也可以使用 GPG Key 签名，这里我们可以选择使用子密钥或者主密钥来完成签名，建议使用子密钥，因为主密钥可以撤销子密钥，也可以生成多个子密钥。输入git config --global user.signingkey 57D615B2EC5D45C1命令，在全局配置 commit 时签名使用的 key id，此处使用的便是 ssb 一行的子密钥。然后输入git config --global commit.gpgsign true，设置所有的 git 提交都需要签名。或者上述两个 git 命令都可以通过去掉--global字段，在当前所在的 git 仓库目录运行，这将仅作用于当前所在的 git 仓库。 接着在.bashrc其他 shell 配置文件中添加如下环境变量：\nexport GPG_TTY=$(tty) 重新进入终端并输入killall gpg-agent杀掉 gpg 进程，然后可以随便提交一次，能够成功提交就代表设置成功了。也可以通过git log --show-signature命令查看详细的信息。 至此就配置成功了，当 push 到 GitHub 之后，就可以看到认证了。不过除此之外，关于 GPG 的使用还有一些内容要注意的。\n备份和主密钥的撤销 你可以在不同的设备上使用同一份 GPG Key，你可以使用同一个子密钥，也可以生成多个子密钥供不同设备使用。一般来说我们只需要导出主密钥的公钥和私钥即可。输入gpg --armor --export DCA603FF70CDCDD0 \u0026gt; public-key.asc命令导出主密钥公钥，输入gpg --armor --export-secret-keys DCA603FF70CDCDD0 \u0026gt; private-key.asc命令导出主密钥私钥。这将会得到两个文件，这两个文件需要妥善保存，并且可以通过如下的命令在另一台设备导入：\ngpg --import public-key.asc gpg --import private-key.asc 除此之外，最好生成并备份撤销证书，这可以在密钥泄露之后对 GPG Key 进行撤销操作，撤销之后的密钥对就相当于作废了。输入gpg --output revoke.asc --gen-revoke DCA603FF70CDCDD0命令得到revoke.asc文件，即为撤销证书。撤销的命令是gpg --import revoke.asc，注意该操作不可逆，谨慎操作。 另外，撤销和删除是不同的操作，这个命令gpg --delete-keys DCA603FF70CDCDD0会删除主密钥，一般来说只有撤销或者设置密钥不被信任之后才可以删除，否则 gpg 会阻止删除操作。\n子密钥的生成和撤销 输入gpg --edit-key DCA603FF70CDCDD0命令，进入一个交互模式，效果如下：\n➜ ~ gpg --edit-key DCA603FF70CDCDD0 gpg (GnuPG) 2.2.27; Copyright (C) 2021 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Secret key is available. sec rsa4096/DCA603FF70CDCDD0 created: 2023-06-03 expires: never usage: SC trust: ultimate validity: ultimate ssb rsa4096/57D615B2EC5D45C1 created: 2023-06-03 expires: never usage: E [ultimate] (1). eyebrowkang \u0026lt;48169104+eyebrowkang@users.noreply.github.com\u0026gt; gpg\u0026gt; 你可以输入 help 查看所有命令，这里我们输入addkey会输出创建主密钥时类似的提示，选择算法：\ngpg\u0026gt; addkey Please select what kind of key you want: (3) DSA (sign only) (4) RSA (sign only) (5) Elgamal (encrypt only) (6) RSA (encrypt only) (14) Existing key from card Your selection? 这里就选一个 4 好了，只用于签名，之后的各种提示和前面一样，不做赘述，最终输出如下：\nsec rsa4096/DCA603FF70CDCDD0 created: 2023-06-03 expires: never usage: SC trust: ultimate validity: ultimate ssb rsa4096/57D615B2EC5D45C1 created: 2023-06-03 expires: never usage: E ssb rsa4096/6D27CF5A5037DE52 created: 2023-06-03 expires: never usage: S [ultimate] (1). eyebrowkang \u0026lt;48169104+eyebrowkang@users.noreply.github.com\u0026gt; 会发现，多了一个密钥，其中 usage 的值为 S，代表 sign，这就是刚刚生成的子密钥，然后输入save保存并退出，就可以使用了。 如果想要撤销一个子密钥，先进入交互模式gpg --edit-key DCA603FF70CDCDD0，比如我想撤销第二个子密钥，那就输入key 2，会输出：\ngpg\u0026gt; key 2 sec rsa4096/DCA603FF70CDCDD0 created: 2023-06-03 expires: never usage: SC trust: ultimate validity: ultimate ssb rsa4096/57D615B2EC5D45C1 created: 2023-06-03 expires: never usage: E ssb* rsa4096/6D27CF5A5037DE52 created: 2023-06-03 expires: never usage: S [ultimate] (1). eyebrowkang \u0026lt;48169104+eyebrowkang@users.noreply.github.com\u0026gt; 这里第二个 ssb 后面多个一个星号，代表它被选中了，然后输入revkey回车，经过一系列交互之后得到如下的输出结果：\ngpg\u0026gt; revkey Do you really want to revoke this subkey? (y/N) y Please select the reason for the revocation: 0 = No reason specified 1 = Key has been compromised 2 = Key is superseded 3 = Key is no longer used Q = Cancel Your decision? 0 Enter an optional description; end it with an empty line: \u0026gt; Reason for revocation: No reason specified (No description given) Is this okay? (y/N) y sec rsa4096/DCA603FF70CDCDD0 created: 2023-06-03 expires: never usage: SC trust: ultimate validity: ultimate ssb rsa4096/57D615B2EC5D45C1 created: 2023-06-03 expires: never usage: E The following key was revoked on 2023-06-03 by RSA key DCA603FF70CDCDD0 eyebrowkang \u0026lt;48169104+eyebrowkang@users.noreply.github.com\u0026gt; ssb rsa4096/6D27CF5A5037DE52 created: 2023-06-03 revoked: 2023-06-03 usage: S [ultimate] (1). eyebrowkang \u0026lt;48169104+eyebrowkang@users.noreply.github.com\u0026gt; 然后输入save回车，就成功撤销了这个子密钥。再次查询列表时会发现该子密钥已经不存在：\n➜ ~ gpg --list-secret-keys --keyid-format LONG /root/.gnupg/pubring.kbx ------------------------ sec rsa4096/DCA603FF70CDCDD0 2023-06-03 [SC] B1D32AD243FEFF42CCEBF9A9DCA603FF70CDCDD0 uid [ultimate] eyebrowkang \u0026lt;48169104+eyebrowkang@users.noreply.github.com\u0026gt; ssb rsa4096/57D615B2EC5D45C1 2023-06-03 [E] 不过这并没有删除子密钥，如果要删除的话，可以再次进入交互模式并选中对应的子密钥，然后通过delkey命令来删除。\n其他配置 如果是 MacOS，并且想要让设备记住 gpg 密码，那么需要安装pinentry-mac这个包，然后运行echo \u0026quot;pinentry-program $(which pinentry-mac)\u0026quot; \u0026gt;\u0026gt; ~/.gnupg/gpg-agent.conf命令，并重启 gpg-agent。\n如果仅需要在 git 的 submodule 中设置签名，那么就先进入该 submodule，然后运行git config user.signingkey 57D615B2EC5D45C1即可。\n常用命令汇总 gpg --full-generate-key gpg --list-keys gpg --list-secret-keys --keyid-format LONG gpg --armor --export \u0026lt;key-id\u0026gt; gpg --output revoke.asc --gen-revoke \u0026lt;key-id\u0026gt; gpg --edit-key \u0026lt;key-id\u0026gt; gpg --armor --export \u0026lt;key-id\u0026gt; \u0026gt; public-key.asc gpg --armor --export-secret-keys \u0026lt;key-id\u0026gt; \u0026gt; private-key.asc gpg --import public-key.asc gpg --import private-key.asc gpg --delete-keys \u0026lt;key-id\u0026gt; gpg --delete-secret-keys \u0026lt;key-id\u0026gt; git config user.signingkey \u0026lt;key-id\u0026gt; git config commit.gpgsign true ","permalink":"https://tech.eyebrowkang.com/posts/2023-06-03-%E9%85%8D%E7%BD%AE%E4%BD%A0%E7%9A%84github%E5%8C%85%E6%8B%ACssh%E5%92%8Cgpg/","summary":"由于有时候会在不同的主机上修改我的一些 GitHub 仓库代码，这些代码大多是一些配置文件，比如各种 dotfile，每次增加一台新机器就需要重新设置一遍，因此在此记录一下配置步骤，后续考虑尽可能集成到一个脚本中。以下内容并不适用 Windows 系统。\nSSH 相关配置 首先来配置 ssh，虽然这不是唯一的推送方式，但是在一台较为常用且安全性得到保障（没有暴露在公网）的机器上，我认为还是 SSH 配置更好一些，可以免去每次粘贴一大段 token 的必要，接下来的部分主要都参考自 GitHub 的官方文档。\n生成 SSH 密钥 这里用到的命令是ssh-keygen，如果你的系统没有这个命令，那么访问这里来查看并安装对应的包。你可以通过man ssh-keygen查看该命令的详细手册，在其诸多选项中，此处只会用到 -t 选项，这决定了生成密钥使用的算法。 打开终端，在命令行输入ssh-keygen -t ed25519，然后会得到类似这样的输出：\nGenerating public/private ed25519 key pair. Enter file in which to save the key (/root/.ssh/id_ed25519): 这是在让我们选择密钥的保存位置，如果这是第一次生成，那么直接回车即可，接着会出现以下内容：\nEnter passphrase (empty for no passphrase): 这是让我们为此密钥设置一个密码，设置完成之后按回车，或者直接按回车代表不设置密码，然后重复密码并回车，一个密钥就生成了。这个命令的整体输出类似这样：\n➜ ~ ssh-keygen -t ed25519 Generating public/private ed25519 key pair. Enter file in which to save the key (/root/.ssh/id_ed25519): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.","title":"配置你的GitHub(包括SSH和GPG)"},{"content":"前端项目中 ESlint 和 Prettier 可以说几乎是标配了，大多数情况下一些官方脚手架会帮助你设置好相关配置，这可以为框架使用者省掉不少麻烦。但是有时候你需要自定义一些 lint 或者 format 规则，或者是你单纯的想学习这类工具怎么使用，那么就需要学习一下如何自己配置了。\n简单了解 ESLint 和 Prettier 这是ESLint 官网上的原话：\nESLint statically analyzes your code to quickly find problems. It is built into most text editors and you can run ESLint as part of your continuous integration pipeline.\n翻译成中文，意思就是：\nESLint 静态地分析你的代码，以快速发现问题。它内置在大多数文本编辑器中，你可以把 ESLint 作为持续集成管道的一部分来运行。\n也就是说 ESLint 是一个代码质量检查工具，可以发现代码中的问题。实际上，我们阅读 ESLint 的文档可以了解到，ESLint 同时还有规范代码样式的功能，它同时也是一个代码格式化工具。\n那么Prettier呢，官方说它是An opinionated code formatter，一个有主见的代码格式化工具。这样看来似乎 Prettier 也是一个代码格式化工具，但是 ESLint 就可以进行代码格式化了，难道不重复吗。事实上确实会有项目只配置使用 ESLint，但是我个人更倾向于各司其职，专门的工具用来做专门的事情。这里举一个例子，比如在 CI/CD 的过程中只需要运行 lint 的相关任务，因为这个时候代码本身的样式其实并不重要。如果 ESLint 既要处理代码质量问题又要处理代码本身的样式问题，显然是没有必要的，浪费了部署时间，也增加了部署失败的风险。更多的原因和观点可以从二者的官网或者互联网上找到，这里对此不再赘述。 也正是因为如此，我们可以对 ESLint 和 Prettier 分别进行配置，互不干扰。\n配置 ESLint 一般来说我倾向于先配置 ESLint，因为它更重要，能有效减少开发人员的低级错误。其配置方法也很简单，不论语言是JavaScript还是TypeScript，不管用的前端框架是Angular、React还是Vue等等，你都只需要安装一个eslint包即可。这里以使用pnpm为例：\npnpm add -D eslint 但是这仅仅是能用而已，如果要达到好用的级别，显然还需要进行一些配置。这里以三大框架为例子，分别说一下我个人建议使用的相关规则。这些规则都是 github 上开源的仓库，通过 npm 包的形式进行安装，并写入在 eslint 的配置文件中。\nAngular 由于 Angular 这个框架比较复杂和庞大，如果你想从零开始一个一个包的安装，那是非常复杂的，所以此处就以使用官方脚手架为例，angular-eslint仓库帮我们把所有的工作都完成了，只需要简单的运行ng add @angular-eslint/schematics即可。\nReact React 对自身的定义是一个 JavaScript UI 库，所以从零开始安装包的话相对要简单很多。 如果你没有使用 TypeScript，那么只需要按照eslint-plugin-react这个仓库的说明安装eslint-plugin-react包，并且添加这段代码到.eslint.json（你有多种配置文件格式可选，这里以 json 文件为例）配置文件中\n\u0026#34;extends\u0026#34;: [ \u0026#34;eslint:recommended\u0026#34;, \u0026#34;plugin:react/recommended\u0026#34; ] 如果你使用了 TypeScript，那么还需要按照typescript-eslint网站的说明，安装@typescript-eslint/parser @typescript-eslint/eslint-plugin这两个包，并且将配置文件修改为如下代码：\n\u0026#34;extends\u0026#34;: [ \u0026#34;eslint:recommended\u0026#34;, \u0026#34;plugin:react/recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34; ], \u0026#34;parser\u0026#34;: \u0026#34;@typescript-eslint/parser\u0026#34;, \u0026#34;plugins\u0026#34;: [\u0026#34;@typescript-eslint\u0026#34;], \u0026#34;root\u0026#34;: true Vue Vue 虽然自身定义为一个渐进式的前端框架，但是实际上其脚手架的复杂程度相对较低，也是可以自己逐步从零安装的。 其配置和 React 类似，只不过对应的框架插件由eslint-plugin-react变更为了eslint-plugin-vue而已。\n配置 Prettier 要配置 Prettier，我们需要先把 ESLint 的格式化功能给关闭，以免二者发生冲突，这里是 Prettier 的整合建议。其中有提到一个插件，eslint-config-prettier，按照其说明，先运行：\npnpm add -D eslint-config-prettier 然后在 eslint 的配置文件中，为第一层级的 extends 数组添加一个 prettier 元素，如下所示：\n{ \u0026#34;extends\u0026#34;: [\u0026#34;some-other-config-you-use\u0026#34;, \u0026#34;prettier\u0026#34;] } 这里针对eslint-plugin-prettier插件进行一个额外的说明，我个人在项目中一直使用这个插件，知道最近才将其移除。这个插件将 prettier 以 eslint 插件的形式运行，实际上还是没有将二者分离开，所以在此就不会用到这个插件了。 接下来就是安装 prettier 了：\npnpm add -D prettier 配置编辑器 上述的过程只是完成了这两个工具的安装和基本配置，如果我们真正要使用它们，往往还需要和编辑器结合。这里以三个编辑器为例，简单介绍下如何配置，分别是VSCode、WebStorm和NeoVim。前两者在安装插件之后默认会开启错误、警告的提示，NeoVim自定义程度较高，这里也仅仅是以我个人的配置为例。 我个人的习惯是当保存文件时自动运行如下两个命令：\neslint --fix; prettier --check --write . 即自动修复可修复的代码质量问题以及代码格式问题。代码格式化是没有什么阻碍的，但是并不是所有的代码质量问题都可以自动修复，具体可以参考 ESLint 的详细规则文档。\nVSCode 首先需要安装dbaeumer.vscode-eslint和esbenp.prettier-vscode两个插件，当前我安装的版本分别为2.4.0和9.12.0。 ESLint 的保存自动修复是默认打开的，你可以在defaultSettings.json文件中找到如下配置内容：\n{ // Specifies the code action mode. Possible values are \u0026#39;all\u0026#39; and \u0026#39;problems\u0026#39;. // - all: Fixes all possible problems in the file. This option might take some time. // - problems: Fixes only reported problems that have non-overlapping textual edits. This option runs a lot faster. \u0026#34;eslint.codeActionsOnSave.mode\u0026#34;: \u0026#34;all\u0026#34; } Prettier 的自动格式化设置分为两步，首先需要为指定的文件后缀设置默认的 formatter，接着再设置编辑器保存自动格式化，比如你可以在settings.json中添加如下配置：\n{ \u0026#34;[javascript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;editor.formatOnSave\u0026#34;: true } 那么当你保存一个 js 文件时，就是默认使用 prettier 格式化。类似的，你可以添加vue、typescript等文件的格式化工具。\nWebStorm WebStorm 默认会安装好 ESLint 和 Prettier 的插件，你只需要直接在设置中搜索两个插件的名字即可找到相关设置界面。 或者在打开设置界面之后，你需要依次点击Languages \u0026amp; Frameworks -\u0026gt; JavaScript -\u0026gt; Code Quality Tools -\u0026gt; ESLint来设置 ESLint；依次点击Languages \u0026amp; Frameworks -\u0026gt; JavaScript -\u0026gt;Prettier来设置 Prettier。 二者界面类似，勾选类似Run on Save文字前的方框即可。\nNeoVim NeoVim 的配置方案有很多种，我个人当前使用的是 lsp 搭配 null-ls，这是我的nvim 配置，其中相关的配置如下：\nnull_ls.setup({ sources = { null_ls.builtins.code_actions.eslint_d, null_ls.builtins.diagnostics.eslint_d, null_ls.builtins.formatting.eslint_d, null_ls.builtins.formatting.prettierd, }, on_attach = function(client, bufnr) if client.supports_method(\u0026#34;textDocument/formatting\u0026#34;) then vim.api.nvim_clear_autocmds({ group = augroup, buffer = bufnr }) vim.api.nvim_create_autocmd(\u0026#34;BufWritePre\u0026#34;, { group = augroup, buffer = bufnr, callback = function() vim.lsp.buf.format({ bufnr = bufnr }) end, }) end end, }) 自定义配置 无论你是按照前面所描述的从零开始安装相关包，还是直接使用脚手架生成了相关配置文件，当你发现推荐的配置和你自身或者团队的偏好有所不同时，往往都要对配置进行修改或自定义。详细的配置说明建议还是参考文档，这里只针对一些常用配置进行说明。\nESLint 首先说配置文件的后缀，你可以使用.js .cjs .json .yaml等等文件格式，这个取决于个人和团队喜好，我偏好使用.eslintrc.json一些。然后针对几个配置项进行一些简单的讲解：\nroot: 这个选项的值是一个布尔值，默认是 false。默认情况下 eslint 会逐级向上的寻找 eslint 配置并进行合并，直到项目的根目录。更改为 true 之后则意味着到此为止，当前配置即为最顶级的配置了，无论是否在根目录。 extends: 这个选项的值是一个字符串或者数组，用来扩展配置，你可以通过添加eslint:recommended来使用推荐的配置，也可以像上面那样安装一些插件，使用插件的配置，多个配置最终会进行合并，其优先级为越靠后优先级越高。 rules: 这个选项也是一个数组，根据这里的规则说明进行配置。比如你使用了某个插件的配置扩展了几十条规则，但是其中只有一两条具体规则和你的需求不符，那么就可以写在这里。这个选项的优先级一定比 extends 更高。 overrides: 这个选项的优先级又比 rules 更高。主要用来覆盖 rules，比如不同位置的子文件夹或者文件需要应用不同的规则，这里可以使用正则表达式对个别情况进行自定义。 此外你还可以通过.eslintignore文件指定需要忽略的文件夹 Prettier Prettier 的配置文件后缀也有很多，同样的，我偏好使用 json 文件格式。其配置选项相对于 ESLint 要少非常多，我个人是使用默认配置的，所以在此简单说一下配置文件应该是什么样子吧：\n{ \u0026#34;tabWidth\u0026#34;: 4, \u0026#34;semi\u0026#34;: false, \u0026#34;singleQuote\u0026#34;: true } 每个配置项都有默认值，如果你想要的值和默认值不同，那么就自行设置。 同样的，你也可以通过.prettierignore来指定需要忽略的文件。\n总结 虽然这两个工具的配置项比较多，看起来头很大，但是其配置逻辑是比较简单的。可以总结如下图： 我个人是先在网上找到推荐配置，然后使用过程中发现有不合适的点再进行规则的覆盖。 最终实现的效果是用的顺手，能快速发现问题，且代码格式整洁，便于阅读。\n","permalink":"https://tech.eyebrowkang.com/posts/2023-05-16-eslint%E5%92%8Cprettier%E9%85%8D%E7%BD%AE/","summary":"前端项目中 ESlint 和 Prettier 可以说几乎是标配了，大多数情况下一些官方脚手架会帮助你设置好相关配置，这可以为框架使用者省掉不少麻烦。但是有时候你需要自定义一些 lint 或者 format 规则，或者是你单纯的想学习这类工具怎么使用，那么就需要学习一下如何自己配置了。\n简单了解 ESLint 和 Prettier 这是ESLint 官网上的原话：\nESLint statically analyzes your code to quickly find problems. It is built into most text editors and you can run ESLint as part of your continuous integration pipeline.\n翻译成中文，意思就是：\nESLint 静态地分析你的代码，以快速发现问题。它内置在大多数文本编辑器中，你可以把 ESLint 作为持续集成管道的一部分来运行。\n也就是说 ESLint 是一个代码质量检查工具，可以发现代码中的问题。实际上，我们阅读 ESLint 的文档可以了解到，ESLint 同时还有规范代码样式的功能，它同时也是一个代码格式化工具。\n那么Prettier呢，官方说它是An opinionated code formatter，一个有主见的代码格式化工具。这样看来似乎 Prettier 也是一个代码格式化工具，但是 ESLint 就可以进行代码格式化了，难道不重复吗。事实上确实会有项目只配置使用 ESLint，但是我个人更倾向于各司其职，专门的工具用来做专门的事情。这里举一个例子，比如在 CI/CD 的过程中只需要运行 lint 的相关任务，因为这个时候代码本身的样式其实并不重要。如果 ESLint 既要处理代码质量问题又要处理代码本身的样式问题，显然是没有必要的，浪费了部署时间，也增加了部署失败的风险。更多的原因和观点可以从二者的官网或者互联网上找到，这里对此不再赘述。 也正是因为如此，我们可以对 ESLint 和 Prettier 分别进行配置，互不干扰。","title":"ESLint和Prettier配置"},{"content":"本篇文章我们来手写一个 fetch 的适配器，目的是加深对 axios 请求发送及接收过程的理解，不借助这个包的时候我们自己也能够对请求了如指掌。正常情况下我们应该自己写一个函数来传入到 axios 的配置中，但是为了简化书写过程和方便调试（我们可能会用到一些 xhr 适配器中的代码），我们直接在 axios 的lib/adapters目录下新建一个名为fetch.js的文件，并且在lib/defaults/index.js文件中进行如下修改：\n- if (typeof XMLHttpRequest !== \u0026#39;undefined\u0026#39;) { + if (typeof fetch !== \u0026#39;undefined\u0026#39;) { + // use fetch adapter if available + console.log(\u0026#39;---Using fetch adapter---\u0026#39;); + adapter = require(\u0026#39;../adapters/fetch\u0026#39;); + } else if (typeof XMLHttpRequest !== \u0026#39;undefined\u0026#39;) { 在我们完成 fetch adapter 的编写之后，可以通过 axios 项目中的打包流程(npm run build)得到一个魔改后的 axios 包。下面我们开始写代码。\n首先要了解fetch和xhr请求的一些异同，二者功能上两者大体相似，比如它们的 header、requestData 的要求都是一样的；但是有一些属性只有 fetch 有，比如 mode、signal 等，有一些属性只有 xhr 有，比如 timeout、upload 等。但是这两个请求最大的不同点在于 xhr 的使用方法是通过回调来完成的，因此会有load error abort等一系列事件，它们的语法在阅读的时候会比较分散，类似 nodejs 的EventEmitter，而 fetch 方法的使用则是 ES6 的 Promise，链式的形式看起来会更现代一些，也更符合当下的使用习惯。\nfetch 就是一个 promise，因此也就不需要像 xhr 那么繁琐的先new XMLHttpRequest()再调用其 open 方法等一系列操作，fetch 只有两个参数，resource和options，其中 resource 可以是一个Request 对象，也可以是一个 URL 字符串或者能字符串化为 URL 的对象，options 则有诸多属性，常用的有 method、body、headers 等。在这里我们为了简化，默认 fetch 的第一个参数就是字符串，这样就可以直接使用 xhr 文件中的buildURL方法来得到完整的 url，用于请求的发送，至于 method、body 的获取也是和 xhr 完全一致，由于XMLHttpRequest对象有setRequestHeader方法，因此在调用 open 方法后，再设置 headers 时需要通过此方法设置，而 fetch 则必须在调用之前将对应的 headers 设置 OK。其他的属性大多为 fetch 独有，因此可以利用条件判断来讲需要的属性添加到 options 对象中。由于 fetch 没有事件，因此 xhr 文件中的诸多事件，fetch 都不需要，只需要对其进行响应正常返回(.then)和运行出错(.catch)两种处理即可。比如 xhr 中的 abort/error/timeout 事件都可以用 catch 捕获并处理。\n其中 timeout 属性 fetch 是没有的，但是我们可以通过其他方法实现这个超时的报错，这里使用一种简单的但不太完善的方法，使用Promise.race方法，由于 fetch 是一个 promise，我们可以再创建一个设定时间的只用于 reject 的 promise，来完成超时的报错，但是仅此而已的话是有问题的，因为它并不会中止请求，超时的请求，浏览器仍会等待直到响应。当然可以通过AbortController对象来进行请求的中止，但是因为涉及到可能和用户的传入有冲突，所以在这里我们简化为不设置中止。\n最后还需要注意的一点是 responseType 这个设置项，xhr 对象可以直接设置这个属性，用于指定返回内容的类型，但是 fetch 并不能在请求发出前设置，而是在响应正常返回Response 对象之后，可以通过调用其对应的方法对返回的ReadableStream进行不同的操作，得到指定的响应类型的数据。\n更多的内容可以在这里获取修改后的代码，可以通过与 xhr 文件对比来加深对于浏览器 fetch 方法和 xhr 方法的请求发送的理解。\n至此，axios 源码解析就完成了，本系列文章用到的是指定的 commit，我将其代码放在我的 GitHub 上。虽然 axios 还在不断的更新和提交，但是其代码和核心部分是没有太大的变化的，同时更重要的是要理解这个经典的库当中的一些编程的思想和细节，这就需要读者细细揣摩了。\n","permalink":"https://tech.eyebrowkang.com/posts/2022-07-30-axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%BA%94/","summary":"本篇文章我们来手写一个 fetch 的适配器，目的是加深对 axios 请求发送及接收过程的理解，不借助这个包的时候我们自己也能够对请求了如指掌。正常情况下我们应该自己写一个函数来传入到 axios 的配置中，但是为了简化书写过程和方便调试（我们可能会用到一些 xhr 适配器中的代码），我们直接在 axios 的lib/adapters目录下新建一个名为fetch.js的文件，并且在lib/defaults/index.js文件中进行如下修改：\n- if (typeof XMLHttpRequest !== \u0026#39;undefined\u0026#39;) { + if (typeof fetch !== \u0026#39;undefined\u0026#39;) { + // use fetch adapter if available + console.log(\u0026#39;---Using fetch adapter---\u0026#39;); + adapter = require(\u0026#39;../adapters/fetch\u0026#39;); + } else if (typeof XMLHttpRequest !== \u0026#39;undefined\u0026#39;) { 在我们完成 fetch adapter 的编写之后，可以通过 axios 项目中的打包流程(npm run build)得到一个魔改后的 axios 包。下面我们开始写代码。\n首先要了解fetch和xhr请求的一些异同，二者功能上两者大体相似，比如它们的 header、requestData 的要求都是一样的；但是有一些属性只有 fetch 有，比如 mode、signal 等，有一些属性只有 xhr 有，比如 timeout、upload 等。但是这两个请求最大的不同点在于 xhr 的使用方法是通过回调来完成的，因此会有load error abort等一系列事件，它们的语法在阅读的时候会比较分散，类似 nodejs 的EventEmitter，而 fetch 方法的使用则是 ES6 的 Promise，链式的形式看起来会更现代一些，也更符合当下的使用习惯。","title":"axios源码解析（五）"},{"content":"前面的文章中有简单提到过，我认为最能够一目了然的看 axios 配置的地方除了文档之外就是根目录下的index.d.ts文件，无论你是否懂 typescript，找到AxiosRequestConfig这个接口很轻松就可以看懂。并且它相较于文档更具时效性。当然，绝大多数配置项只需要看文档就可以明白如何使用，url、method、baseURL、headers、data 这几个都是最基础和常用的，看文档就可以了，cancelToken 和 signal 实际上作用相同，我们可以忽略前者，后者在上篇文章中已经详细介绍过了，我们挑选几个具有代表性的依次介绍下，剩下的可以按照同样的思路去看源码来确认有什么用处。\ntransformRequest/transformResponse 这两个配置我们只看类型有点看不太懂，它们的类型基本相似，都是函数或者以函数为元素的数组。首先，我们看一下文档的说明，transformRequest可以允许我们在请求发送之前改变请求体，仅限于PUT, POST,PATCH,DELETE四种方法，数组中最后一个函数返回的一定是字符串或者是Buffer ArrayBuffer FormData Stream之一的实例；transformResponse则可以允许我们在响应传递到 then/catch 之前改变响应，这其实就是前面有提过一句的响应格式化。那么这个配置为什么我们几乎不会用呢？因为 axios 有默认值，并且这个默认值覆盖了足够多的场景。打开lib/defaults/index.js文件，axios 提供的默认值都可以在这个文件中找到，我们找到这两个参数的默认值来看一下。\naxios 源码对于函数的命名是非常符合语义化原则的，你可以不需要看内部函数实现就明白这个函数的功能，比如normalizeHeaderName这个函数，如同函数名的意思一样，是用来标准化请求头的名称的。我们看transformRequest的默认值，从代码可以看出来，这个函数主要做一件事就是为数据设置匹配的Content-Type头字段，如果一个请求携带的数据是一个URLSearchParams对象，那么对应的 Content-Type 应该是application/x-www-form-urlencoded;charset=utf-8，并且要将数据转化为字符串再发送。下面对于文件列表和 FormData 的处理稍显复杂，它涉及到了另一个配置，env.FormData，还涉及到一个第三方包，但是目的是一样的，都是要确保请求数据和请求头是匹配的，避免请求因此而发送不成功。\n下面看transformResponse的默认函数，这里也会用到另一个配置，transitional，这个字段我们应该是比较眼熟的，因为我们在Axios.prototype.request方法中曾经见到过它，并且忽略了这个条件语句块。现在，我们可以看一下这个配置项在transformResponse中的作用是什么，至于 request 方法中的作用，稍后大家可以自己研究一下。可以在lib/defaults/transitional.js文件中看到transitional的默认值是一个对象，有三个键值对，在这里用到了前两个，我们按照默认值来执行这个函数的话，这个函数的作用就是在数据（此处的数据指的是经过响应拦截器处理之后的接口返回数据）是字符串并且不为空的情况下，试图通过调用JSON.parse 方法对其进行解析，如果解析出错则不执行任何操作，静默处理。\nparamsSerializer 这个配置项是一个函数，可以通过全局搜索快速找到其用法，在lib/helpers/buildURL.js文件中的同名函数中，它作为最后一个参数用于构建 URL。buildURL 的调用位置在适配器中，这个可以自行查找，我们看函数体的代码，一共有三个部分，第一部分检测是否有参数，如果没有就直接返回 url，此时这个配置项是不会用到的；第二部分的条件语句一共有三个分支，如果用户配置了paramsSerializer，则按照这个配置对参数执行操作，否则执行另外两个分支对应的操作。实际上，我们可以把另外的两个分支当成是 axios 默认为我们设置的paramsSerializer 配置，我们可以通过检查 axios 的这个配置是否能满足我们的需求，来确定是否有必要自定义此配置。第二个分支不用多说，如果参数是一个URLSearchParam对象，则将其转化为字符串；复杂些的是第三个分支，如果 params 不是一个可迭代的对象，那么第二部分开头定义的serializedParams变量将在此分支被赋值为空字符串，这将导致直接略过第三部分，同样直接返回 url，而如果 params 是一个可迭代对象，那么将对其中每个元素的值和键（或索引）进行解析和编码，目的是避免出现特殊字符导致浏览器解析失败，最终通过\u0026amp;符号连接起来并将其赋给serializedParams；然后就到了第三部分，这里会对 url 再进行一次检查，看 url 中是否存在#，# 右边都属于 url 的哈希值，然后再用?或\u0026amp;符号拼接前面提到的serializedParams变量，具体应该用什么符号这属于 URL 的相关知识，在此不做赘述。最终一个拼接完成的 URL 将会被返回。\nadapter 适配器也是可以自定义配置的，即使 axios 已经提供了两个非常强大的适配器（一个可以用于浏览器环境，一个用于 nodejs 环境）。虽然我们去阅读适配器的代码时，看起来非常复杂，不过这主要是因为要处理各种可能的错误情况，实际上适配器就是真正发送请求的那一步，它是一个返回 promise 的函数，这个 promise 将在请求正常响应的情况下被 resolve，其他各种错误出现时则被 reject。所以我们也可以照着样子去写一个自定义的适配器。不过这可以留在下一篇文章中完成。\n其他配置 剩下的配置比较简单，比如timeout用于设置一个请求的超时时间，即请求发送之后经过timeout毫秒还没有响应的话，请求将会中止；timeoutErrorMessage用于设置超时之后的报错信息。withCredentials xsrfCookieName等几个配置只针对浏览器环境，responseEncoding maxContentLength等几个配置只针对 nodejs。由于这些配置比较少用且在 axios 的用法非常简单，所以在此不做赘述了。\n总结 axios 本身是简单的，虽然看上去它的配置项很多，但实际上我们最常用的几项是 url、method、params、data，然后可能会用到 baseURL、headers、timeout、signal/cancelToken；至于其他的配置用到的频率就相对来说低很多了，因为前面那些配置足以让我们很好的处理请求的整个生命周期。通过分析 axios 的源码我们可以学到很多东西，包括代码目录及内容的组织结构，模块的抽离，一些工具函数的小技巧，甚至是函数的命名等等，最后一篇我们将手写一个使用 fetch API 的适配器，来深入了解下其中的流程。\n","permalink":"https://tech.eyebrowkang.com/posts/2022-06-16-axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E5%9B%9B/","summary":"前面的文章中有简单提到过，我认为最能够一目了然的看 axios 配置的地方除了文档之外就是根目录下的index.d.ts文件，无论你是否懂 typescript，找到AxiosRequestConfig这个接口很轻松就可以看懂。并且它相较于文档更具时效性。当然，绝大多数配置项只需要看文档就可以明白如何使用，url、method、baseURL、headers、data 这几个都是最基础和常用的，看文档就可以了，cancelToken 和 signal 实际上作用相同，我们可以忽略前者，后者在上篇文章中已经详细介绍过了，我们挑选几个具有代表性的依次介绍下，剩下的可以按照同样的思路去看源码来确认有什么用处。\ntransformRequest/transformResponse 这两个配置我们只看类型有点看不太懂，它们的类型基本相似，都是函数或者以函数为元素的数组。首先，我们看一下文档的说明，transformRequest可以允许我们在请求发送之前改变请求体，仅限于PUT, POST,PATCH,DELETE四种方法，数组中最后一个函数返回的一定是字符串或者是Buffer ArrayBuffer FormData Stream之一的实例；transformResponse则可以允许我们在响应传递到 then/catch 之前改变响应，这其实就是前面有提过一句的响应格式化。那么这个配置为什么我们几乎不会用呢？因为 axios 有默认值，并且这个默认值覆盖了足够多的场景。打开lib/defaults/index.js文件，axios 提供的默认值都可以在这个文件中找到，我们找到这两个参数的默认值来看一下。\naxios 源码对于函数的命名是非常符合语义化原则的，你可以不需要看内部函数实现就明白这个函数的功能，比如normalizeHeaderName这个函数，如同函数名的意思一样，是用来标准化请求头的名称的。我们看transformRequest的默认值，从代码可以看出来，这个函数主要做一件事就是为数据设置匹配的Content-Type头字段，如果一个请求携带的数据是一个URLSearchParams对象，那么对应的 Content-Type 应该是application/x-www-form-urlencoded;charset=utf-8，并且要将数据转化为字符串再发送。下面对于文件列表和 FormData 的处理稍显复杂，它涉及到了另一个配置，env.FormData，还涉及到一个第三方包，但是目的是一样的，都是要确保请求数据和请求头是匹配的，避免请求因此而发送不成功。\n下面看transformResponse的默认函数，这里也会用到另一个配置，transitional，这个字段我们应该是比较眼熟的，因为我们在Axios.prototype.request方法中曾经见到过它，并且忽略了这个条件语句块。现在，我们可以看一下这个配置项在transformResponse中的作用是什么，至于 request 方法中的作用，稍后大家可以自己研究一下。可以在lib/defaults/transitional.js文件中看到transitional的默认值是一个对象，有三个键值对，在这里用到了前两个，我们按照默认值来执行这个函数的话，这个函数的作用就是在数据（此处的数据指的是经过响应拦截器处理之后的接口返回数据）是字符串并且不为空的情况下，试图通过调用JSON.parse 方法对其进行解析，如果解析出错则不执行任何操作，静默处理。\nparamsSerializer 这个配置项是一个函数，可以通过全局搜索快速找到其用法，在lib/helpers/buildURL.js文件中的同名函数中，它作为最后一个参数用于构建 URL。buildURL 的调用位置在适配器中，这个可以自行查找，我们看函数体的代码，一共有三个部分，第一部分检测是否有参数，如果没有就直接返回 url，此时这个配置项是不会用到的；第二部分的条件语句一共有三个分支，如果用户配置了paramsSerializer，则按照这个配置对参数执行操作，否则执行另外两个分支对应的操作。实际上，我们可以把另外的两个分支当成是 axios 默认为我们设置的paramsSerializer 配置，我们可以通过检查 axios 的这个配置是否能满足我们的需求，来确定是否有必要自定义此配置。第二个分支不用多说，如果参数是一个URLSearchParam对象，则将其转化为字符串；复杂些的是第三个分支，如果 params 不是一个可迭代的对象，那么第二部分开头定义的serializedParams变量将在此分支被赋值为空字符串，这将导致直接略过第三部分，同样直接返回 url，而如果 params 是一个可迭代对象，那么将对其中每个元素的值和键（或索引）进行解析和编码，目的是避免出现特殊字符导致浏览器解析失败，最终通过\u0026amp;符号连接起来并将其赋给serializedParams；然后就到了第三部分，这里会对 url 再进行一次检查，看 url 中是否存在#，# 右边都属于 url 的哈希值，然后再用?或\u0026amp;符号拼接前面提到的serializedParams变量，具体应该用什么符号这属于 URL 的相关知识，在此不做赘述。最终一个拼接完成的 URL 将会被返回。\nadapter 适配器也是可以自定义配置的，即使 axios 已经提供了两个非常强大的适配器（一个可以用于浏览器环境，一个用于 nodejs 环境）。虽然我们去阅读适配器的代码时，看起来非常复杂，不过这主要是因为要处理各种可能的错误情况，实际上适配器就是真正发送请求的那一步，它是一个返回 promise 的函数，这个 promise 将在请求正常响应的情况下被 resolve，其他各种错误出现时则被 reject。所以我们也可以照着样子去写一个自定义的适配器。不过这可以留在下一篇文章中完成。\n其他配置 剩下的配置比较简单，比如timeout用于设置一个请求的超时时间，即请求发送之后经过timeout毫秒还没有响应的话，请求将会中止；timeoutErrorMessage用于设置超时之后的报错信息。withCredentials xsrfCookieName等几个配置只针对浏览器环境，responseEncoding maxContentLength等几个配置只针对 nodejs。由于这些配置比较少用且在 axios 的用法非常简单，所以在此不做赘述了。","title":"axios源码解析（四）"},{"content":"本篇我们来看一下 axios 如何中止请求的发送，axios 自v0.22.0版本开始，支持了AbortControllerAPI，而CancelToken则被列入待废弃列表，我们主要对新版本的 API 进行讲解，旧有的 API 则不再进行讲解，实际上二者是类似的。开头先啰嗦一下中止请求发送的使用场景，对于比较简单的应用一般可能用不到，但是当一个网页发送的请求比较多的时候，就会需要了，这里就举一个例子。比如一个页面加载显示了部分内容，另有一部分的请求发送出去了，还没有响应，这时用户跳转到了另外的路由，那么这些未响应的请求实际上是不需要再响应了的，所以此时可以在路由跳转的部分设置取消请求的逻辑，避免旧路由页面拖慢了新路由页面的请求响应速度。\nAbortController API 简介 这个 API 详细的文档在这里，除了 IE 之外的大多浏览器都很好的支持了此 API，并且在 nodejs 15.0 版本也得到了支持，相较于CancelToken使用更加简单。在创建一个AbortController实例之后，可以在通过fetchAPI(其他方法也可以使用，但需要自己配置)发送请求时附带一个实例的 signal 属性值，然后在请求响应之前通过调用实例的 abort 方法就可以中止这个请求。这其中关键部分是这个 signal 属性，它是AbortSignal对象的一个实例，这个对象有两个属性，一个是 aborted，布尔值，用于表明当前的请求是否处于中止状态；另一个是 reason，在前者为 true 的情况下，用于表示中止的原因。这两个属性都是只读的，也就是说，我们无法直接对属性进行赋值，只能通过调用 abort 方法来改变signal.aborted的值，再通过判断此值来决定是否终止请求。\n何处/何时中止请求 了解 axios 在何处可能会中止请求，对于我们使用这个功能有很大的帮助。首先看一下 axios 如何使用这个 API，由于官方文档可能并未实时更新，我们可以在根目录下的index.d.ts文件中找到关于 signal 的配置项，可以看出，这和在 fetch API 中的使用是一样的。那么在 axios 内部是怎样的逻辑呢？通过前面几篇的了解，可以知道 axios 的请求发送过程大致可以分为以下几个部分：\n请求拦截器 request InterceptorManager 发送请求 dispatchRequest 请求适配器 adaptor 请求发送 send / request 请求响应 response 响应格式化 transform 响应拦截器 response InterceptorManager 上一篇分析了 axios 的拦截器，这个模块实际上是对请求的配置进行处理，并不会涉及真正的请求发送，所以自然也就没有中止请求一说。而在拦截器之后，将会进入到dispatchRequest函数内，函数一开头，我们可以看到一个名为throwIfCancellationRequested的函数，其函数体非常简单，就是判断配置中是否存在 signal 属性，如果存在并且 signal 的 aborted 属性是 true 那么就会抛出一个请求取消的错误。也就是说，如果你在请求拦截器处理完成之前取消请求，那么请求会在进入 dispatchRequest 函数的第一时间中止请求的发送。\n那如果中止请求的时候已经执行完请求拦截器的内容了呢？继续看这个函数，处理完配置之后将会进入适配器，这里我们仍旧以 xhr 请求为例，在创建 xhr 对象之后，会监听这个对象的 abort 事件，需要注意，这个并非AbortControllerAPI 的事件，而是 XHR 对象的，我们并不会直接调用它，而是通过AbortControllerAPI 来操作，具体我们继续向下看源码。\n如果配置了 signal 或 cancelToken，那么将进入一个 if 的代码块，这里我们可以看到，如果代码运行到此处时，请求已经被中止了，那么则马上中止请求并抛出错误，而如果没有被中止的话，将会为 signal 添加一个 abort 事件的监听器，一旦监听到 signal 的状态变化为中止状态，则马上执行onCanceled函数，也即手动调用 XHR 对象的 abort 方法，中止请求。既然有添加监听器，那么一定有移除它，我们可以找到，移除它的位置时在 done 函数内部，这个函数将会在响应正常返回或异常报错时执行，也即响应完成时会移除此监听。以上可以了解到，当执行到适配器内部时，只要响应没有返回，在任意时刻都能够中止请求。\n那么至此是否已经结束了呢？毕竟请求都已经响应了。实际上并没有， 因为 axios 还存在一个格式化响应对象和执行响应拦截器的步骤，因此如果如果响应在格式化之前被中止，同样可以成功中止请求。这部分的代码可以在dispatchRequest函数内，adaptor.then的onAdapterResolution回调函数中看到。\n简单梳理一下，当请求发送出去之后，响应格式化之前，任意时刻都可以成功中止请求，而一旦响应已经被格式化了，那么它将被正常返回。由于请求响应到格式化的事件几乎可以忽略，因此我们可以认为，成功中止请求一般要在响应返回之前进行。axios 会在请求拦截器执行完毕、请求适配器执行的任意位置、请求响应之后格式化之前这三个位置进行检测，确保请求能够被及时中止。\naxios 错误处理 除了文档中最基本的错误捕获之外，我们还应当知道 axios 存在有哪些错误类型，在什么位置会出什么样的错误，使用起来更加得心应手。\n首先打开lib/core/AxiosError.js，这里定义了一个基本的 AxiosError，首先你需要简单了解一下 js 中的Error对象以及我们一起来看一下utils.inherits方法。它将第一个参数（构造函数）的原型指向第二个参数（构造函数）的原型，然后，第一个参数将其原型的构造函数指向自身，最后将可能存在的一些属性也附加到自身的原型上，这一系列操作实际上就是一个继承的过程。\n再返回到 AxiosError 文件中来，对于 Error 对象进行更改和增加部分属性值，然后完成继承的操作，同时为 AxiosError 增加一个内置方法toJSON，方便用户输出或记录错误详情。之后再继续对 AxiosError 对象进行完善，定义对应的错误码，以及用于识别错误实例是否属于 Axios 定制 Error 的isAxiosError属性，最后的Axios.from实际上和前面的继承操作类似，用于将一个 Error 对象转化为一个 AxiosError 对象。\n我们来看一下 AxiosError 是怎么用的，还是 xhr 适配器中，我们可以看到有几种错误，当请求中止时，会有Request aborted，当请求出现错误时会有Network Error，还有超时导致的错误、协议不被支持的错误；可以在 lib 文件夹中搜到很多 AxiosError 的用法，可以对不同位置的不同错误码进行简单了解，同时还应当善于使用前面提到的toJSON方法，这可以让我们更清晰和方便的看和记录错误，然后进行深入的原因分析。\n当然了，你也可以自己创建 AxiosError，或者继承它创建一个新的构造函数，用于统一网络请求处的各种错误格式，比如取消请求的CanceledError就是继承自AxiosError。\n总结 对于中止请求，我们在页面复杂的情况下要善于使用，提升页面的性能；对于错误处理，我们要善于利用AxiosError的自定义方法的属性，用于快速识别错误类型以及记录错误，提升分析错误和解决错误的效率。至此，Axios核心的一些源码就简单讲解完了，下一篇文章我们将对 Axios 的其他配置的部分和一些工具函数进行简单的分析。\n","permalink":"https://tech.eyebrowkang.com/posts/2022-06-02-axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%89/","summary":"本篇我们来看一下 axios 如何中止请求的发送，axios 自v0.22.0版本开始，支持了AbortControllerAPI，而CancelToken则被列入待废弃列表，我们主要对新版本的 API 进行讲解，旧有的 API 则不再进行讲解，实际上二者是类似的。开头先啰嗦一下中止请求发送的使用场景，对于比较简单的应用一般可能用不到，但是当一个网页发送的请求比较多的时候，就会需要了，这里就举一个例子。比如一个页面加载显示了部分内容，另有一部分的请求发送出去了，还没有响应，这时用户跳转到了另外的路由，那么这些未响应的请求实际上是不需要再响应了的，所以此时可以在路由跳转的部分设置取消请求的逻辑，避免旧路由页面拖慢了新路由页面的请求响应速度。\nAbortController API 简介 这个 API 详细的文档在这里，除了 IE 之外的大多浏览器都很好的支持了此 API，并且在 nodejs 15.0 版本也得到了支持，相较于CancelToken使用更加简单。在创建一个AbortController实例之后，可以在通过fetchAPI(其他方法也可以使用，但需要自己配置)发送请求时附带一个实例的 signal 属性值，然后在请求响应之前通过调用实例的 abort 方法就可以中止这个请求。这其中关键部分是这个 signal 属性，它是AbortSignal对象的一个实例，这个对象有两个属性，一个是 aborted，布尔值，用于表明当前的请求是否处于中止状态；另一个是 reason，在前者为 true 的情况下，用于表示中止的原因。这两个属性都是只读的，也就是说，我们无法直接对属性进行赋值，只能通过调用 abort 方法来改变signal.aborted的值，再通过判断此值来决定是否终止请求。\n何处/何时中止请求 了解 axios 在何处可能会中止请求，对于我们使用这个功能有很大的帮助。首先看一下 axios 如何使用这个 API，由于官方文档可能并未实时更新，我们可以在根目录下的index.d.ts文件中找到关于 signal 的配置项，可以看出，这和在 fetch API 中的使用是一样的。那么在 axios 内部是怎样的逻辑呢？通过前面几篇的了解，可以知道 axios 的请求发送过程大致可以分为以下几个部分：\n请求拦截器 request InterceptorManager 发送请求 dispatchRequest 请求适配器 adaptor 请求发送 send / request 请求响应 response 响应格式化 transform 响应拦截器 response InterceptorManager 上一篇分析了 axios 的拦截器，这个模块实际上是对请求的配置进行处理，并不会涉及真正的请求发送，所以自然也就没有中止请求一说。而在拦截器之后，将会进入到dispatchRequest函数内，函数一开头，我们可以看到一个名为throwIfCancellationRequested的函数，其函数体非常简单，就是判断配置中是否存在 signal 属性，如果存在并且 signal 的 aborted 属性是 true 那么就会抛出一个请求取消的错误。也就是说，如果你在请求拦截器处理完成之前取消请求，那么请求会在进入 dispatchRequest 函数的第一时间中止请求的发送。","title":"axios源码解析（三）"},{"content":"下面我们来研究一下拦截器是什么？还是lib/core/Axios这个文件的同名函数中，我们在进行整体梳理的时候刻意忽略了一些条件语句中的内容，其中一部分是 interceptors，中文为拦截器，这个属性的初始化是在最开始的函数体内部，通过 new 这个操作符创建了一个 InterceptorManager 的实例，那么我们就先看看这个函数里面是什么样子的。\n拦截器长什么样子 打开lib/core/InterceptorManager.js这个文件，可以看到是非常简单的一个函数，函数体内只有一个handlers属性，初始值是一个空数组，下面是三个添加到函数原型上的方法。\n首先是use方法，接收三个参数，结合上面的注释可以看出来这个方法是将一个对象推入handlers数组，然后返回一个数字，这个数字就是对象的 index，而这个对象中有四个键值对，其中前两个分别用于处理 Promise 成功和失败的情况，synchronous字面理解是用于判断是否同步，而runWhen看不出来，先继续向下看。\n然后是eject方法，这个方法只接收一个参数，就是前面 use 方法的返回值，即 push 进数组的那个对象的 index，如果这个对象还存在就将其置为 null，相当于移除掉了它。\n最后是forEach方法，由于这里面引用了自定义的工具函数utils.forEach，所以我们要跳转过去简单看下这个函数，它接收两个参数，主要逻辑在最后一个 if else 语句中，如果第一个参数是数组，就对其进行遍历，每遍历一次就执行一次第二个参数传入的函数，并且给这个函数传入三个参数，分别是当前元素，当前元素的 index，当前数组；经过前两个 if 块的筛选之后，如果说第一个参数不是数组，那么它就是一个对象，同样对这个对象进行迭代，也是每迭代一次执行一次 fn，fn 的三个参数分别是当前键值对的值，当前键值对的键，和对象自身。下面回到拦截器的 forEach 方法，它接收一个函数，然后对 handlers 进行遍历，如果 h 也就是遍历的当前元素是存在的，也即没有被 eject，那么就以这个元素为唯一参数执行传入的函数。这个元素一定是通过 use 方法 push 进来的那个具有四个键值对的对象。\n拦截器如何处理请求 我们可以通过查看官方示例来了解拦截器最简单的使用方法，可以看到，通过 use 方法添加拦截器，两个函数fulfilled和rejected对应请求发出前和请求出错时的处理情况，通过 eject 方法来移除对应的拦截器。到这里，我们大概可以明白，拦截器是用于在请求发出前对请求进行一个处理，那么具体怎么处理呢？\n处理用户添加的拦截器 我们回到源码，lib/core/Axios.js文件中，找到requestInterceptorChain这里，这是我们上篇文章略过的地方之一，下面我们看下代码。\n请求拦截器的处理：开头定义了两个变量，requestInterceptorChain是一个空数组，synchronousRequestInterceptors是一个初始值为 true 的布尔类型变量。接着调用了拦截器的 forEach 方法，这会对handlers数组中（通过 use 方法添加）的所有拦截器进行遍历，如果这个拦截器存在(没有被 eject)，将以其为参数执行unshiftRequestInterceptors函数。我们看这个函数的内容，可以通过 if 判断中的条件推测出来，runWhen 类似一个检测函数，这个函数默认是不存在的，如果你设置了 runWhen 函数，并且你的配置项不能通过检测，那么在这里拦截器就不会被添加到requestInterceptorChain数组中，也就相当于没有设置拦截器。由于上篇文章就是按照没有拦截器梳理的，我们下面按照拦截器存在来继续看，接着是synchronousRequestInterceptors变量，保持了和当前拦截器中的synchronous属性一致，默认为 false 即异步，最后将这个拦截器的 fulfilled 方法和 rejected 方法依此添加到requestInterceptorChain数组的开头，也就是说如果你设置了多个拦截器，那么最后设置的拦截器会在requestInterceptorChain数组的最前方。例如，你依次添加了 interceptors1, interceptors2 两个拦截器，那么，在requestInterceptorChain数组中元素依次是 interceptors2.fulfilled, interceptors2.rejected, interceptors1.fulfilled, interceptor1.rejected。\n响应拦截器的处理：比请求拦截器更简单些，没有条件判断和同步异步的区分，所有的响应拦截器的 fulfilled 和 rejected 方法都会被添加到responseInterceptorChain数组中，有一点不同是，这里使用的 push 方法，即最后设置的拦截器会在responseInterceptorChain数组的最末端。\n使用拦截器 上面相当于对用户添加的请求和响应拦截器进行了一个处理，筛选出可用的，并按照合适的方式放好，接着就该使用这些拦截器了。接着看源码，如果请求拦截器是异步的，那么请求拦截器的响应拦截器会被拼接到同一个数组中，在前端是请求拦截器，后端是响应拦截器，中间是两个元素，第一个正是上节课也接触到了的dispatchRequest函数，第二个是 undefined。那么现在这个名为 chain 的数组中每两个元素为一对，刚好对应 promise.then 的 fulfilled 和 rejected，比如中间的两个元素中，dispatchRequest 对应 fulfilled，undefined 对应 rejected。接着会制作一个一定 resolve 为 config 的 promise，依次执行这些 promise 的回调函数，并且每执行一次会弹出对应的两个函数，直到 chain 数组中没有元素存在，然后直接返回最后一次执行的 promise，请求结束。\n那么如果请求拦截器是同步的呢？原理是类似的，只不过同步的方法需要通过try...catch...来对配置进行处理，先使用请求拦截器，然后发送请求，最后用上面一样的异步的方法处理响应拦截器，注意前面有提到过，响应拦截器没有同步异步标志，都按照异步处理。最终返回拦截器处理之后的 promise。\n通过设置请求拦截器可以对请求进行一个批处理，比如想要在每次请求发出前打印出 URL 和参数到控制台，那么可以设置一个请求拦截器，只需要写一次console语句，而不必每次发请求都写。假如你想对响应的错误进行统一处理，那么可以设置一个响应拦截器，比如 http 状态码不是 200 就将响应拦截，而不让错误传递到业务逻辑代码中。\n拦截器回顾 所谓拦截器就是一个对象，其中有两个属性是必须的，fulfilled和rejected，分别对应拦截器的前一个 promise 执行成功和失败的处理函数，另外两个属性，一个synchronous用于标识拦截器是否异步，一个runWhen方法用于检测这次请求是否要使用拦截器。然后就是拦截器的执行顺序，请求拦截器后设置的先执行，响应拦截器后设置的后执行。最后有一点，前文没有点明，请求拦截器处理的是 config，而响应拦截器处理的是 response，其原因是中间的dispatchRequest将请求发送出去之后返回的对象是 response。下面一篇文章我们来看 axios 是如何处理错误和取消请求的。\n","permalink":"https://tech.eyebrowkang.com/posts/2022-05-16-axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%BA%8C/","summary":"下面我们来研究一下拦截器是什么？还是lib/core/Axios这个文件的同名函数中，我们在进行整体梳理的时候刻意忽略了一些条件语句中的内容，其中一部分是 interceptors，中文为拦截器，这个属性的初始化是在最开始的函数体内部，通过 new 这个操作符创建了一个 InterceptorManager 的实例，那么我们就先看看这个函数里面是什么样子的。\n拦截器长什么样子 打开lib/core/InterceptorManager.js这个文件，可以看到是非常简单的一个函数，函数体内只有一个handlers属性，初始值是一个空数组，下面是三个添加到函数原型上的方法。\n首先是use方法，接收三个参数，结合上面的注释可以看出来这个方法是将一个对象推入handlers数组，然后返回一个数字，这个数字就是对象的 index，而这个对象中有四个键值对，其中前两个分别用于处理 Promise 成功和失败的情况，synchronous字面理解是用于判断是否同步，而runWhen看不出来，先继续向下看。\n然后是eject方法，这个方法只接收一个参数，就是前面 use 方法的返回值，即 push 进数组的那个对象的 index，如果这个对象还存在就将其置为 null，相当于移除掉了它。\n最后是forEach方法，由于这里面引用了自定义的工具函数utils.forEach，所以我们要跳转过去简单看下这个函数，它接收两个参数，主要逻辑在最后一个 if else 语句中，如果第一个参数是数组，就对其进行遍历，每遍历一次就执行一次第二个参数传入的函数，并且给这个函数传入三个参数，分别是当前元素，当前元素的 index，当前数组；经过前两个 if 块的筛选之后，如果说第一个参数不是数组，那么它就是一个对象，同样对这个对象进行迭代，也是每迭代一次执行一次 fn，fn 的三个参数分别是当前键值对的值，当前键值对的键，和对象自身。下面回到拦截器的 forEach 方法，它接收一个函数，然后对 handlers 进行遍历，如果 h 也就是遍历的当前元素是存在的，也即没有被 eject，那么就以这个元素为唯一参数执行传入的函数。这个元素一定是通过 use 方法 push 进来的那个具有四个键值对的对象。\n拦截器如何处理请求 我们可以通过查看官方示例来了解拦截器最简单的使用方法，可以看到，通过 use 方法添加拦截器，两个函数fulfilled和rejected对应请求发出前和请求出错时的处理情况，通过 eject 方法来移除对应的拦截器。到这里，我们大概可以明白，拦截器是用于在请求发出前对请求进行一个处理，那么具体怎么处理呢？\n处理用户添加的拦截器 我们回到源码，lib/core/Axios.js文件中，找到requestInterceptorChain这里，这是我们上篇文章略过的地方之一，下面我们看下代码。\n请求拦截器的处理：开头定义了两个变量，requestInterceptorChain是一个空数组，synchronousRequestInterceptors是一个初始值为 true 的布尔类型变量。接着调用了拦截器的 forEach 方法，这会对handlers数组中（通过 use 方法添加）的所有拦截器进行遍历，如果这个拦截器存在(没有被 eject)，将以其为参数执行unshiftRequestInterceptors函数。我们看这个函数的内容，可以通过 if 判断中的条件推测出来，runWhen 类似一个检测函数，这个函数默认是不存在的，如果你设置了 runWhen 函数，并且你的配置项不能通过检测，那么在这里拦截器就不会被添加到requestInterceptorChain数组中，也就相当于没有设置拦截器。由于上篇文章就是按照没有拦截器梳理的，我们下面按照拦截器存在来继续看，接着是synchronousRequestInterceptors变量，保持了和当前拦截器中的synchronous属性一致，默认为 false 即异步，最后将这个拦截器的 fulfilled 方法和 rejected 方法依此添加到requestInterceptorChain数组的开头，也就是说如果你设置了多个拦截器，那么最后设置的拦截器会在requestInterceptorChain数组的最前方。例如，你依次添加了 interceptors1, interceptors2 两个拦截器，那么，在requestInterceptorChain数组中元素依次是 interceptors2.fulfilled, interceptors2.","title":"axios源码解析（二）"},{"content":"关于 axios 是什么，以及它的基本使用不在此赘述，可以参考axios 官方文档，非常的详细，这里主要针对 axios 的源码进行解析。本文撰写时的 commit 为bc733fec78326609e751187c9d453cee9bf1993a\n代码目录结构 首先我们可以从axios 的 github 仓库获取到其源码，在深入代码之前，我们先看一下这个项目的目录结构：\n├── .github //github相关文件夹，包括issue模板、PR模板等 ├── dist //axios最新的版本文件，从npm、cdn等获取到的最新版本即是此处文件 ├── examples //axios官方给出的一些例子 ├── lib //最主要的源码部分 ├── sandbox //也是一个简单的例子，可以在sandbox中运行 ├── test //测试各种功能的代码 ├── .eslintrc.js //eslint配置文件 ├── .gitignore //git的忽略文件 ├── .npmignore //npm打包发布的忽略文件 ├── .travis.yml //travis流水线配置文件 ├── CHANGELOG.md //版本变更日志 ├── CODE_OF_CONDUCT.md //贡献者的一些公约 ├── COLLABORATOR_GUIDE.md //提issue、PR等的一些指南 ├── CONTRIBUTING.md //给想要参与贡献和开发人员的具体的技术指导 ├── COOKBOOK.md //axios配合其他库实现强大功能的示例 ├── ECOSYSTEM.md //axios的相关npm包 ├── Gruntfile.js //grunt（一个自动化工具）的配置文件 ├── LICENSE //开源协议 ├── README.md //仓库的说明 ├── SECURITY.md //漏洞上报的地址 ├── UPGRADE_GUIDE.md //版本升级的要点说明 ├── bower.json // bower（一个包管理器）配置文件 ├── index.d.ts // axios的ts类型说明 ├── index.js //仓库的入口文件 ├── karma.conf.js //karma（用来测试的工具）配置文件 ├── package-lock.json //npm配置文件 ├── package.json //npm配置文件 ├── tsconfig.json // ts配置文件 ├── tslint.json // tslint代码检查配置文件 └── webpack.config.js //webpack配置文件 从第一层的目录可以看出来，绝大多数的文件/文件夹是用来规范代码和优化流程的。而此次我们主要分析 axios 的核心源代码，因此我们主要看lib这一个文件夹，那么这个文件夹有什么内容呢？\nlib ├── adapters/ ├── cancel/ ├── core/ ├── defaults/ ├── env/ ├── helpers/ ├── axios.js └── utils.js 可以看到，lib文件夹的结构简单和紧凑很多，包含两个文件和六个文件夹，至于它们的作用我们边阅读源码边理解。\n从入口顺藤摸瓜 我们大致了解了项目的结构之后，就准备阅读源码。首先从入口下手，在第一层级的文件中找到整个仓库的入口即index.js，打开发现只有一行代码，module.exports = require('./lib/axios');，意味着真正的入口文件lib文件夹内，是项目的同名文件。\n打开这个文件，发现其内容也很少，只有 64 行，我们快速的阅读一下，不需要看细节，可以很明显的看到这个文件的核心内容是createInstance函数，其余的部分是在做一个模块的组合，是在给axios这个变量叠加 buff。\nfunction createInstance(defaultConfig) { var context = new Axios(defaultConfig); var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance utils.extend(instance, Axios.prototype, context); // Copy context to instance utils.extend(instance, context); // Factory for creating new instances instance.create = function create(instanceConfig) { return createInstance(mergeConfig(defaultConfig, instanceConfig)); }; return instance; } 代码注释写的非常清晰，这个函数首先创建了一个Axios的实例，然后对实例的属性进行对应的绑定，具体的绑定细节先不深入，最后的位置有一个工厂函数，目的是把createInstance函数暴露出去，允许通过调用axios的create方法再创建新的实例。\n这个函数中的核心Axios是什么呢？找到对应的文件lib/core/Axios.js打开，可以看到Axios也是一个函数，当然函数本质上也是对象object，它有几个属性，在这个文件占据最多篇幅的，也是最为关键的属性是request。axios 这个包的目的就是去发送请求，我们可以使用类似axios('/url') 来发送请求并获取响应，再结合这个Axios函数的主体就是 request 方法，可以猜测这个函数应该是 axios 这个项目的核心逻辑函数。\n分析 request 方法 Axios.request也是一个函数，可以接受两个参数，从命名可以看出来，两个参数都是配置项，只是url这个配置项可以简写在第一个参数，request的前几行就是对两个参数进行合并。继续往下看这个函数的代码，有一个条件判断语句，如果给transitional 这个变量赋值就会执行一个操作，不赋值则继续，像这种不会影响函数整体逻辑的条件，我们先不去看赋值会如何，先记下来，忽略它，然后继续向下看。\nthis.interceptors这个属性是第一次用，从字面意思理解，这是一个拦截器，可以找到其赋值的位置，在Axios函数体中，有request和response两个属性，它们的初始值都是一样的new InterceptorManager() 。回到request函数中，这里有一个forEach，它只接受了一个参数，且这个参数是一个函数，显然不是 js 中可迭代对象的那个forEach，也可以先不去管它。接着看unshiftRequestInterceptors，unshift 代表会有元素被添加到数组的最前端，再看pushResponseInterceptors，push 代表会有元素被添加到数组的最末端。那么这里的元素就是这两个函数的参数，其变量名就是拦截器。继续向下，又是一个条件判断，如果进入判断块最终会返回一个 promise，request 就结束了，否则会继续，我们依然忽略条件判断。这个请求拦截器的数组requestInterceptorChain如果有元素在其中就会进入 while 循环，同样，先继续。执行dispatchRequest，再判断响应拦截器的数组responseInterceptorChain有没有元素，没有的话返回一个 promise，这个 promise 正是dispatchRequest的返回值。我们把所有的条件都忽略之后，关键的语句就是dispantchRequest这个函数了，我们找到其声明。\n上来有一个throwIfCancellationRequested，这是干什么的？可以看到它的函数声明就在上面，注释写了如果取消请求就抛出一个取消的错误，是一个错误抛出的函数，不影响主体逻辑，我们可以先不管。继续向下，会对配置中的 data、headers 等进行各种变换，最终返回的 promise 是adapter的执行结果的一个变换，成功的话返回格式化的 response，否则返回格式化的 reason。这个adapter，字面意思是适配器，如果没有传值的话就是默认的，我们找到默认的 adapter。可以找到getDefaultAdapter这个很简单的函数，意思是 adapter 在不同的条件下会有不同的值，我们先看第一种可能性。\n找到xhrAdapter这个函数，它的返回值是一个 promise，我们在dispatchXhrRequest这个函数中找到 resolve 和 reject 的位置，可以看到 resolve 只在一个位置出现，一个名为settle的函数内部，settle 的上一层是一个名为onloadend的函数，而这个函数并未被显式执行，而是在一个条件判断中，如果request这个变量也有onloadend属性会将其值更改为此函数，否则会在另一个名为handleLoad的函数中处理，那么我们就要看这个request是什么？找到其定义，可以发现，其实request就是一个XMLHttpRequest对象，可以在MDN上看到很详细的解释，这个 onloadend 其实是这个对象的一个事件，意味着请求结束。也就是说dispatchXhrRequest也即xhrAdapter这个函数成功被 resolve 的条件就是请求结束，有结束就一定有开始，那么这个请求是在什么时候被发出的呢？我们对源代码搜索可以找到，在新建XMLHttpRequest对象之后，马上就使用 open 方法初始化了一个请求，在最后将这个请求通过 send 方法发送出去。resolve 看完之后，再看 reject 的情况，可以发现有很多地方可能会被 reject，找到对应位置，然后对应到 xhr 的事件，可能的情况有请求被中止、请求出错、请求超时等等，对应各类异常。\n所以，从整体上看，这个适配器函数的工作就是创建一个 xhr 对象，然后发送请求，最后如果一切正常则 resolve 这个响应，否则 reject。同样的我们可以打开lib/adapters/http.js这个文件，按照同样的方法进行梳理，工作目的和原理是一模一样的，只是将XMLHttpRequest 对象替换为了 nodejs 中的 http 模块，相关用法也进行了微调。\n由此，我们基本梳理了lib/core/Axios.js这个文件中Axios函数的request属性对应的方法的主要逻辑，就是通过判断当前环境是浏览器还是其他的 js 运行时（具体逻辑在getDefaultAdapter 函数中），然后将请求发送出去。\n结合 axios 的具体使用方法，以上的逻辑对应的就是，我们直接在项目通过诸如axios('/url')、axios.post('/url', {method: 'post', body: {}})等方法调用时，请求发出的逻辑。在浏览器环境下就是创建一个 xhr 对象并发出请求，然后接收响应；nodejs 环境则是通过 http 类完成。很纯粹和基本的使用方法，不过 axios 在这个逻辑中帮我们增加了比较完善的错误处理机制。而 axios 还有一些强大的功能，就是我们在Axios.request 方法中忽略的几个条件判断，其中一个比较重要的叫做拦截器，它有什么作用呢，具体我们下篇来说。\n最后补充一下，axios 如何实现能够通过直接调用axios.post、axios.delete等方法就直接指定了对应的请求 method 呢？可以在lib/core/Axios.js这个文件中找到，通过其自己定义的utils.forEach方法，进行一个转换，最终还是调用的 request 方法，实际上就是帮助用户写了一个快捷方式，能更方便的使用。这个函数中的核心方法就是axios.request。\n","permalink":"https://tech.eyebrowkang.com/posts/2022-05-03-axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%80/","summary":"关于 axios 是什么，以及它的基本使用不在此赘述，可以参考axios 官方文档，非常的详细，这里主要针对 axios 的源码进行解析。本文撰写时的 commit 为bc733fec78326609e751187c9d453cee9bf1993a\n代码目录结构 首先我们可以从axios 的 github 仓库获取到其源码，在深入代码之前，我们先看一下这个项目的目录结构：\n├── .github //github相关文件夹，包括issue模板、PR模板等 ├── dist //axios最新的版本文件，从npm、cdn等获取到的最新版本即是此处文件 ├── examples //axios官方给出的一些例子 ├── lib //最主要的源码部分 ├── sandbox //也是一个简单的例子，可以在sandbox中运行 ├── test //测试各种功能的代码 ├── .eslintrc.js //eslint配置文件 ├── .gitignore //git的忽略文件 ├── .npmignore //npm打包发布的忽略文件 ├── .travis.yml //travis流水线配置文件 ├── CHANGELOG.md //版本变更日志 ├── CODE_OF_CONDUCT.md //贡献者的一些公约 ├── COLLABORATOR_GUIDE.md //提issue、PR等的一些指南 ├── CONTRIBUTING.md //给想要参与贡献和开发人员的具体的技术指导 ├── COOKBOOK.md //axios配合其他库实现强大功能的示例 ├── ECOSYSTEM.md //axios的相关npm包 ├── Gruntfile.js //grunt（一个自动化工具）的配置文件 ├── LICENSE //开源协议 ├── README.md //仓库的说明 ├── SECURITY.","title":"axios源码解析（一）"},{"content":"我们都知道 react 有一个官方的脚手架 create-react-app，一条命令就可以让你使用 react 编写代码，但是在这个脚手架中 react 代码的打包过程对我们是完全隐藏的。\n对于一个新手来说，比如我刚接触到这个工具的时候是充满了疑惑的，为什么我不能npm install react react-dom然后直接使用script标签引入呢？为什么这些代码要打包才可以使用？打包很复杂吗？怎么进行打包呢？\n上面这些问题我们暂且不做回答，下面直接使用 esbuild 这个打包工具，带大家从零开始制作一个简单的 react 页面。\nesbuild 是一个比较新的打包工具，这里是它的官方文档，相较于 create-react-app 使用的 webpack 而言，它的优点是快，缺点是不支持 css module 等特性。当然了，如果你一定要使用 css module 的话，那么很抱歉这篇文章不能帮助到你\n开始动手 1. 初始化 确定你已经安装好了node和npm，然后打开电脑的命令行，新建一个文件夹，并运行npm init -y\n2. 安装依赖 安装需要用到的依赖，我们会用到react react-dom esbuild这三个包\n3. 新建文件 打开你的 vs code 或者其他编辑器，新建一个 html 文件，以及一个 src 文件夹（包含一个 css 文件和一个 jsx 文件）\n4. 写代码 在你的 jsx 和 css 中随便写点什么\nimport React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import \u0026#34;./style.css\u0026#34;; const root = document.createElement(\u0026#34;div\u0026#34;); root.className = \u0026#34;root\u0026#34;; document.body.appendChild(root); const App = () =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1 className=\u0026#34;esbuild\u0026#34;\u0026gt;Hello, Esbuild!\u0026lt;/h1\u0026gt; \u0026lt;h1 className=\u0026#34;react\u0026#34;\u0026gt;Hello, React!\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); }; ReactDOM.render(\u0026lt;App /\u0026gt;, root); .esbuild { color: rgb(247, 209, 71); } .react { color: rgb(97, 218, 251); } 5. 进行打包 在你的 package.json 文件的 script 标签中加入\u0026quot;build\u0026quot;: \u0026quot;esbuild src/app.jsx --outfile=build/index.js --bundle\u0026quot;，这代表以 src 文件夹中的 app.jsx 为入口，build 文件夹的 index.js 为输出进行打包。 然后在终端中输入npm run build命令\n现在你的目录下面多出了一个 build 文件夹和两个文件\n6. 查看效果 这时我们打开之前新建的 html 文件，将其初始化然后将 build 文件夹中的两个文件链接上去\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./build/index.css\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Esbuild and React\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;./build/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 然后可以使用 vs code 中的 live server 打开或者直接通过浏览器打开，页面就可以正常显示了\n7. 完善功能 仅有这些的话，对于开发而言还远远不够，如何达到原生 js 开发时的实时更改的效果呢，我们可以在 package.json 中之前 build 命令后面加一个--watch或者增加一个 watch 命令 \u0026quot;watch\u0026quot;: \u0026quot;esbuild src/app.jsx --outfile=build/index.js --bundle --watch\u0026quot;然后借助 vs code 的 live server 插件就可以实现实时的效果了。\n总结 本文结合 react 对 esbuid 这个打包工具进行了简单使用，最后一步实现方法并不是唯一的，还可以使用 esbuild 的 serve 功能实现，大家可以阅读官方文档探索。\n本文写作的初衷是为初学者推荐一款合适的打包工具，在我看来，webpack 这个工具非常的臃肿，尽管它功能非常丰富，但是初学之时并不是很友好，esbuild 除了打包速度飞快，对于 ts 文件的处理也是非常友好，不需要设置各种 loader，配置简单，是一个非常“轻”的选择。 除此之外，vite 也是一个不错的选择。\n","permalink":"https://tech.eyebrowkang.com/posts/2021-07-07-%E7%BB%93%E5%90%88react%E4%B8%8A%E6%89%8Besbuild%E6%96%B0%E6%89%8B%E9%80%82%E7%94%A8/","summary":"我们都知道 react 有一个官方的脚手架 create-react-app，一条命令就可以让你使用 react 编写代码，但是在这个脚手架中 react 代码的打包过程对我们是完全隐藏的。\n对于一个新手来说，比如我刚接触到这个工具的时候是充满了疑惑的，为什么我不能npm install react react-dom然后直接使用script标签引入呢？为什么这些代码要打包才可以使用？打包很复杂吗？怎么进行打包呢？\n上面这些问题我们暂且不做回答，下面直接使用 esbuild 这个打包工具，带大家从零开始制作一个简单的 react 页面。\nesbuild 是一个比较新的打包工具，这里是它的官方文档，相较于 create-react-app 使用的 webpack 而言，它的优点是快，缺点是不支持 css module 等特性。当然了，如果你一定要使用 css module 的话，那么很抱歉这篇文章不能帮助到你\n开始动手 1. 初始化 确定你已经安装好了node和npm，然后打开电脑的命令行，新建一个文件夹，并运行npm init -y\n2. 安装依赖 安装需要用到的依赖，我们会用到react react-dom esbuild这三个包\n3. 新建文件 打开你的 vs code 或者其他编辑器，新建一个 html 文件，以及一个 src 文件夹（包含一个 css 文件和一个 jsx 文件）\n4. 写代码 在你的 jsx 和 css 中随便写点什么\nimport React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import \u0026#34;.","title":"结合React上手esbuild（新手适用）"},{"content":"本篇文章分享下题目中三种打包工具在开发和生产模式中的实际使用感受，希望能对你有所帮助。我使用的技术栈是react+typescript+express，开发模式使用打包工具自带的开发服务器，生产模式使用一个简单的 express 服务器，代码放在这里GitHub。由于本文目的是对比，因此对于配置项的详细介绍以及具体代码就省略掉了，需要的可以自行查看官方文档（vite、webpack、esbuild）。\n配置文件 Typtescript 支持 vite 和 webpack 均支持*.config.ts格式的配置文件，而 esbuild 由于没有对应的cli启动工具，因此其需要使用node *.js命令来启动，因此不适合使用 ts。\n开发模式 开发模式的对比项目主要包括配置难度、启动速度、热更新及路由的配置三个项目。\n配置难度 vite: 最简单，几乎零配置。vite 官方有许多模版可以直接使用，但即使不用模版，你只需要配置一个 react 热更新插件就足够了。不过，如果你使用的框架没有对应插件，或者你不希望使用默认的配置，那么你就需要仔细阅读文档，并且你需要同时学习 vite 和 rollup 甚至 esbuild 的文档，才能够随心所欲的配置。 esbuild: 比较简单。esbuild 的配置项并不多，你只需要增加一个 servedir 就可以使用它的开发服务器了。 webpack: 比较复杂。这里我使用的是 webpack5，只进行最基础的配置和代码分割优化，但是仍然需要安装一大堆的第三方包。其余的配置都需要根据文档一步步进行配置，对于新手并不是特别友好。另外，由于 ts-loader 实在太慢，我这里使用了 esbuild-loader（应该是最快加载 ts 文件的 loader 了）。 启动速度（使用相同的代码及入口） esbuild: 最快。 vite: 比 esbuild 慢近 10 倍，但实际感知不强，依然非常的快。 webpack: 比 vite 慢 10 倍有余，实际能感知，需要等待。 热更新及react-router路由配置 vite: 配置官方插件后支持热更新及react-router webpack: 热更新需要在 devServer 中开启，react-router也需要进行配置。 esbuild: 开发服务器不支持热更新，不支持react-router配置 生产模式 生产模式主要对比代码分离和速度两个项目。其配置难度可以参考开发模式，另外，实际三个打包工具都可以将开发模式和生产模式的配置集成在一个配置文件中，但是这里为了对比，我分别写了开发和生产的配置文件。\n代码分离 和 打包速度 esbuild: 速度最快，但代码分离效果最差。可以看到，最大的 js 文件有 4.8mb，这是无法部署在生产环境中的，如果你需要再优化，配置项目中是没有相关配置的，你需要修改你的代码。 vite: 速度一般，代码分离效果不错。可以看到最大的 js 文件约 1mb，已经勉强可以部署了。而且这使用的是默认的配置，也就是几乎零配置的效果，你还可以通过 rollup 配置项来继续优化。 webpack: 速度一般，代码分离效果不错。这里 webpack 之所以能和 vite 打包速度相差无几，很大程度是 esbuild-loader 的原因，代码分离的情况和 vite 差不多，都是最大的 js 文件约 1mb，并且也可以继续进行优化。 总结 vite: vite 在配置难易度和速度方面确实较 webpack 有很大优势，对于新手而言极为友好，开发过程的体验可以说是三者中最为舒适的。 webpack: webpack 的速度是一个大问题，虽然借助 esbuild-loader 加快了打包速度，但是仍逊于 vite，不过其优势在于插件及各类功能的丰富，而且不依赖于其他工具，当你的项目需要较多的插件时，很大概率你要使用 webpack。 esbuild: esbuild 确实很快。但是除了快其他的体验都不好，这是一个不成熟的工具，期待其功能的完善。 个人建议 如果是一个新开始的项目，建议使用 vite 作为打包工具，你可以使用或不使用官方的模版，都不会影响你的使用体验，之后随着项目变得复杂，你可能会需要使用 webpack，但是到时候再转变我认为不是一个困难的事情。如果是一个老的项目，那么你需要慎重考虑，或许优化现有的工具是一个更好的选择。\n","permalink":"https://tech.eyebrowkang.com/posts/2020-09-05-vite_vs_webpack_vs_esbuild/","summary":"本篇文章分享下题目中三种打包工具在开发和生产模式中的实际使用感受，希望能对你有所帮助。我使用的技术栈是react+typescript+express，开发模式使用打包工具自带的开发服务器，生产模式使用一个简单的 express 服务器，代码放在这里GitHub。由于本文目的是对比，因此对于配置项的详细介绍以及具体代码就省略掉了，需要的可以自行查看官方文档（vite、webpack、esbuild）。\n配置文件 Typtescript 支持 vite 和 webpack 均支持*.config.ts格式的配置文件，而 esbuild 由于没有对应的cli启动工具，因此其需要使用node *.js命令来启动，因此不适合使用 ts。\n开发模式 开发模式的对比项目主要包括配置难度、启动速度、热更新及路由的配置三个项目。\n配置难度 vite: 最简单，几乎零配置。vite 官方有许多模版可以直接使用，但即使不用模版，你只需要配置一个 react 热更新插件就足够了。不过，如果你使用的框架没有对应插件，或者你不希望使用默认的配置，那么你就需要仔细阅读文档，并且你需要同时学习 vite 和 rollup 甚至 esbuild 的文档，才能够随心所欲的配置。 esbuild: 比较简单。esbuild 的配置项并不多，你只需要增加一个 servedir 就可以使用它的开发服务器了。 webpack: 比较复杂。这里我使用的是 webpack5，只进行最基础的配置和代码分割优化，但是仍然需要安装一大堆的第三方包。其余的配置都需要根据文档一步步进行配置，对于新手并不是特别友好。另外，由于 ts-loader 实在太慢，我这里使用了 esbuild-loader（应该是最快加载 ts 文件的 loader 了）。 启动速度（使用相同的代码及入口） esbuild: 最快。 vite: 比 esbuild 慢近 10 倍，但实际感知不强，依然非常的快。 webpack: 比 vite 慢 10 倍有余，实际能感知，需要等待。 热更新及react-router路由配置 vite: 配置官方插件后支持热更新及react-router webpack: 热更新需要在 devServer 中开启，react-router也需要进行配置。 esbuild: 开发服务器不支持热更新，不支持react-router配置 生产模式 生产模式主要对比代码分离和速度两个项目。其配置难度可以参考开发模式，另外，实际三个打包工具都可以将开发模式和生产模式的配置集成在一个配置文件中，但是这里为了对比，我分别写了开发和生产的配置文件。\n代码分离 和 打包速度 esbuild: 速度最快，但代码分离效果最差。可以看到，最大的 js 文件有 4.","title":"Vite vs Webpack vs Esbuild"}]