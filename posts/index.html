<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Share Some Tech</title>
<meta name=keywords content><meta name=description content="Posts - Share Some Tech"><meta name=author content="eyebrowkang"><link rel=canonical href=https://tech.eyebrowkang.com/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.1b82bbed8b13f853704558d527b681efaea938ce91e6ae8903e8b19e73b1b0f8.css integrity="sha256-G4K77YsT+FNwRVjVJ7aB766pOM6R5q6JA+ixnnOxsPg=" rel="preload stylesheet" as=style><link rel=icon href=https://static.eyebrowkang.com/eyebrow.png><link rel=icon type=image/png sizes=16x16 href=https://tech.eyebrowkang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tech.eyebrowkang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://static.eyebrowkang.com/eyebrow.png><link rel=mask-icon href=https://static.eyebrowkang.com/eyebrow.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://tech.eyebrowkang.com/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content="share some technology things"><meta property="og:type" content="website"><meta property="og:url" content="https://tech.eyebrowkang.com/posts/"><meta property="og:image" content="https://tech.eyebrowkang.com/blog-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tech.eyebrowkang.com/blog-cover.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content="share some technology things"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://tech.eyebrowkang.com/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tech.eyebrowkang.com accesskey=h title="Share Some Tech (Alt + H)">Share Some Tech</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tech.eyebrowkang.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://tech.eyebrowkang.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://tech.eyebrowkang.com/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://tech.eyebrowkang.com>主页</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2>配置你的GitHub(包括SSH和GPG)</h2></header><div class=entry-content><p>由于有时候会在不同的主机上修改我的一些 GitHub 仓库代码，这些代码大多是一些配置文件，比如各种 dotfile，每次增加一台新机器就需要重新设置一遍，因此在此记录一下配置步骤，后续考虑尽可能集成到一个脚本中。以下内容并不适用 Windows 系统。
SSH 相关配置 首先来配置 ssh，虽然这不是唯一的推送方式，但是在一台较为常用且安全性得到保障（没有暴露在公网）的机器上，我认为还是 SSH 配置更好一些，可以免去每次粘贴一大段 token 的必要，接下来的部分主要都参考自 GitHub 的官方文档。
生成 SSH 密钥 这里用到的命令是ssh-keygen，如果你的系统没有这个命令，那么访问这里来查看并安装对应的包。你可以通过man ssh-keygen查看该命令的详细手册，在其诸多选项中，此处只会用到 -t 选项，这决定了生成密钥使用的算法。 打开终端，在命令行输入ssh-keygen -t ed25519，然后会得到类似这样的输出：
Generating public/private ed25519 key pair. Enter file in which to save the key (/root/.ssh/id_ed25519): 这是在让我们选择密钥的保存位置，如果这是第一次生成，那么直接回车即可，接着会出现以下内容：
Enter passphrase (empty for no passphrase): 这是让我们为此密钥设置一个密码，设置完成之后按回车，或者直接按回车代表不设置密码，然后重复密码并回车，一个密钥就生成了。这个命令的整体输出类似这样：
➜ ~ ssh-keygen -t ed25519 Generating public/private ed25519 key pair. Enter file in which to save the key (/root/.ssh/id_ed25519): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/....</p></div><footer class=entry-footer><span title='2023-06-03 18:27:50 +0800 CST'>六月 3, 2023</span>&nbsp;·&nbsp;eyebrowkang</footer><a class=entry-link aria-label="post link to 配置你的GitHub(包括SSH和GPG)" href=https://tech.eyebrowkang.com/posts/2023-06-03-%E9%85%8D%E7%BD%AE%E4%BD%A0%E7%9A%84github%E5%8C%85%E6%8B%ACssh%E5%92%8Cgpg/></a></article><article class=post-entry><header class=entry-header><h2>ESLint和Prettier配置</h2></header><div class=entry-content><p>前端项目中 ESlint 和 Prettier 可以说几乎是标配了，大多数情况下一些官方脚手架会帮助你设置好相关配置，这可以为框架使用者省掉不少麻烦。但是有时候你需要自定义一些 lint 或者 format 规则，或者是你单纯的想学习这类工具怎么使用，那么就需要学习一下如何自己配置了。
简单了解 ESLint 和 Prettier 这是ESLint 官网上的原话：
ESLint statically analyzes your code to quickly find problems. It is built into most text editors and you can run ESLint as part of your continuous integration pipeline.
翻译成中文，意思就是：
ESLint 静态地分析你的代码，以快速发现问题。它内置在大多数文本编辑器中，你可以把 ESLint 作为持续集成管道的一部分来运行。
也就是说 ESLint 是一个代码质量检查工具，可以发现代码中的问题。实际上，我们阅读 ESLint 的文档可以了解到，ESLint 同时还有规范代码样式的功能，它同时也是一个代码格式化工具。
那么Prettier呢，官方说它是An opinionated code formatter，一个有主见的代码格式化工具。这样看来似乎 Prettier 也是一个代码格式化工具，但是 ESLint 就可以进行代码格式化了，难道不重复吗。事实上确实会有项目只配置使用 ESLint，但是我个人更倾向于各司其职，专门的工具用来做专门的事情。这里举一个例子，比如在 CI/CD 的过程中只需要运行 lint 的相关任务，因为这个时候代码本身的样式其实并不重要。如果 ESLint 既要处理代码质量问题又要处理代码本身的样式问题，显然是没有必要的，浪费了部署时间，也增加了部署失败的风险。更多的原因和观点可以从二者的官网或者互联网上找到，这里对此不再赘述。 也正是因为如此，我们可以对 ESLint 和 Prettier 分别进行配置，互不干扰。...</p></div><footer class=entry-footer><span title='2023-05-16 22:57:49 +0800 CST'>五月 16, 2023</span>&nbsp;·&nbsp;eyebrowkang</footer><a class=entry-link aria-label="post link to ESLint和Prettier配置" href=https://tech.eyebrowkang.com/posts/2023-05-16-eslint%E5%92%8Cprettier%E9%85%8D%E7%BD%AE/></a></article><article class=post-entry><header class=entry-header><h2>axios源码解析（五）</h2></header><div class=entry-content><p>本篇文章我们来手写一个 fetch 的适配器，目的是加深对 axios 请求发送及接收过程的理解，不借助这个包的时候我们自己也能够对请求了如指掌。正常情况下我们应该自己写一个函数来传入到 axios 的配置中，但是为了简化书写过程和方便调试（我们可能会用到一些 xhr 适配器中的代码），我们直接在 axios 的lib/adapters目录下新建一个名为fetch.js的文件，并且在lib/defaults/index.js文件中进行如下修改：
- if (typeof XMLHttpRequest !== 'undefined') { + if (typeof fetch !== 'undefined') { + // use fetch adapter if available + console.log('---Using fetch adapter---'); + adapter = require('../adapters/fetch'); + } else if (typeof XMLHttpRequest !== 'undefined') { 在我们完成 fetch adapter 的编写之后，可以通过 axios 项目中的打包流程(npm run build)得到一个魔改后的 axios 包。下面我们开始写代码。
首先要了解fetch和xhr请求的一些异同，二者功能上两者大体相似，比如它们的 header、requestData 的要求都是一样的；但是有一些属性只有 fetch 有，比如 mode、signal 等，有一些属性只有 xhr 有，比如 timeout、upload 等。但是这两个请求最大的不同点在于 xhr 的使用方法是通过回调来完成的，因此会有load error abort等一系列事件，它们的语法在阅读的时候会比较分散，类似 nodejs 的EventEmitter，而 fetch 方法的使用则是 ES6 的 Promise，链式的形式看起来会更现代一些，也更符合当下的使用习惯。...</p></div><footer class=entry-footer><span title='2022-07-30 21:03:59 +0800 CST'>七月 30, 2022</span>&nbsp;·&nbsp;eyebrowkang</footer><a class=entry-link aria-label="post link to axios源码解析（五）" href=https://tech.eyebrowkang.com/posts/2022-07-30-axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%BA%94/></a></article><article class=post-entry><header class=entry-header><h2>axios源码解析（四）</h2></header><div class=entry-content><p>前面的文章中有简单提到过，我认为最能够一目了然的看 axios 配置的地方除了文档之外就是根目录下的index.d.ts文件，无论你是否懂 typescript，找到AxiosRequestConfig这个接口很轻松就可以看懂。并且它相较于文档更具时效性。当然，绝大多数配置项只需要看文档就可以明白如何使用，url、method、baseURL、headers、data 这几个都是最基础和常用的，看文档就可以了，cancelToken 和 signal 实际上作用相同，我们可以忽略前者，后者在上篇文章中已经详细介绍过了，我们挑选几个具有代表性的依次介绍下，剩下的可以按照同样的思路去看源码来确认有什么用处。
transformRequest/transformResponse 这两个配置我们只看类型有点看不太懂，它们的类型基本相似，都是函数或者以函数为元素的数组。首先，我们看一下文档的说明，transformRequest可以允许我们在请求发送之前改变请求体，仅限于PUT, POST,PATCH,DELETE四种方法，数组中最后一个函数返回的一定是字符串或者是Buffer ArrayBuffer FormData Stream之一的实例；transformResponse则可以允许我们在响应传递到 then/catch 之前改变响应，这其实就是前面有提过一句的响应格式化。那么这个配置为什么我们几乎不会用呢？因为 axios 有默认值，并且这个默认值覆盖了足够多的场景。打开lib/defaults/index.js文件，axios 提供的默认值都可以在这个文件中找到，我们找到这两个参数的默认值来看一下。
axios 源码对于函数的命名是非常符合语义化原则的，你可以不需要看内部函数实现就明白这个函数的功能，比如normalizeHeaderName这个函数，如同函数名的意思一样，是用来标准化请求头的名称的。我们看transformRequest的默认值，从代码可以看出来，这个函数主要做一件事就是为数据设置匹配的Content-Type头字段，如果一个请求携带的数据是一个URLSearchParams对象，那么对应的 Content-Type 应该是application/x-www-form-urlencoded;charset=utf-8，并且要将数据转化为字符串再发送。下面对于文件列表和 FormData 的处理稍显复杂，它涉及到了另一个配置，env.FormData，还涉及到一个第三方包，但是目的是一样的，都是要确保请求数据和请求头是匹配的，避免请求因此而发送不成功。
下面看transformResponse的默认函数，这里也会用到另一个配置，transitional，这个字段我们应该是比较眼熟的，因为我们在Axios.prototype.request方法中曾经见到过它，并且忽略了这个条件语句块。现在，我们可以看一下这个配置项在transformResponse中的作用是什么，至于 request 方法中的作用，稍后大家可以自己研究一下。可以在lib/defaults/transitional.js文件中看到transitional的默认值是一个对象，有三个键值对，在这里用到了前两个，我们按照默认值来执行这个函数的话，这个函数的作用就是在数据（此处的数据指的是经过响应拦截器处理之后的接口返回数据）是字符串并且不为空的情况下，试图通过调用JSON.parse 方法对其进行解析，如果解析出错则不执行任何操作，静默处理。
paramsSerializer 这个配置项是一个函数，可以通过全局搜索快速找到其用法，在lib/helpers/buildURL.js文件中的同名函数中，它作为最后一个参数用于构建 URL。buildURL 的调用位置在适配器中，这个可以自行查找，我们看函数体的代码，一共有三个部分，第一部分检测是否有参数，如果没有就直接返回 url，此时这个配置项是不会用到的；第二部分的条件语句一共有三个分支，如果用户配置了paramsSerializer，则按照这个配置对参数执行操作，否则执行另外两个分支对应的操作。实际上，我们可以把另外的两个分支当成是 axios 默认为我们设置的paramsSerializer 配置，我们可以通过检查 axios 的这个配置是否能满足我们的需求，来确定是否有必要自定义此配置。第二个分支不用多说，如果参数是一个URLSearchParam对象，则将其转化为字符串；复杂些的是第三个分支，如果 params 不是一个可迭代的对象，那么第二部分开头定义的serializedParams变量将在此分支被赋值为空字符串，这将导致直接略过第三部分，同样直接返回 url，而如果 params 是一个可迭代对象，那么将对其中每个元素的值和键（或索引）进行解析和编码，目的是避免出现特殊字符导致浏览器解析失败，最终通过&符号连接起来并将其赋给serializedParams；然后就到了第三部分，这里会对 url 再进行一次检查，看 url 中是否存在#，# 右边都属于 url 的哈希值，然后再用?或&符号拼接前面提到的serializedParams变量，具体应该用什么符号这属于 URL 的相关知识，在此不做赘述。最终一个拼接完成的 URL 将会被返回。
adapter 适配器也是可以自定义配置的，即使 axios 已经提供了两个非常强大的适配器（一个可以用于浏览器环境，一个用于 nodejs 环境）。虽然我们去阅读适配器的代码时，看起来非常复杂，不过这主要是因为要处理各种可能的错误情况，实际上适配器就是真正发送请求的那一步，它是一个返回 promise 的函数，这个 promise 将在请求正常响应的情况下被 resolve，其他各种错误出现时则被 reject。所以我们也可以照着样子去写一个自定义的适配器。不过这可以留在下一篇文章中完成。
其他配置 剩下的配置比较简单，比如timeout用于设置一个请求的超时时间，即请求发送之后经过timeout毫秒还没有响应的话，请求将会中止；timeoutErrorMessage用于设置超时之后的报错信息。withCredentials xsrfCookieName等几个配置只针对浏览器环境，responseEncoding maxContentLength等几个配置只针对 nodejs。由于这些配置比较少用且在 axios 的用法非常简单，所以在此不做赘述了。...</p></div><footer class=entry-footer><span title='2022-06-16 21:03:51 +0800 CST'>六月 16, 2022</span>&nbsp;·&nbsp;eyebrowkang</footer><a class=entry-link aria-label="post link to axios源码解析（四）" href=https://tech.eyebrowkang.com/posts/2022-06-16-axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E5%9B%9B/></a></article><article class=post-entry><header class=entry-header><h2>axios源码解析（三）</h2></header><div class=entry-content><p>本篇我们来看一下 axios 如何中止请求的发送，axios 自v0.22.0版本开始，支持了AbortControllerAPI，而CancelToken则被列入待废弃列表，我们主要对新版本的 API 进行讲解，旧有的 API 则不再进行讲解，实际上二者是类似的。开头先啰嗦一下中止请求发送的使用场景，对于比较简单的应用一般可能用不到，但是当一个网页发送的请求比较多的时候，就会需要了，这里就举一个例子。比如一个页面加载显示了部分内容，另有一部分的请求发送出去了，还没有响应，这时用户跳转到了另外的路由，那么这些未响应的请求实际上是不需要再响应了的，所以此时可以在路由跳转的部分设置取消请求的逻辑，避免旧路由页面拖慢了新路由页面的请求响应速度。
AbortController API 简介 这个 API 详细的文档在这里，除了 IE 之外的大多浏览器都很好的支持了此 API，并且在 nodejs 15.0 版本也得到了支持，相较于CancelToken使用更加简单。在创建一个AbortController实例之后，可以在通过fetchAPI(其他方法也可以使用，但需要自己配置)发送请求时附带一个实例的 signal 属性值，然后在请求响应之前通过调用实例的 abort 方法就可以中止这个请求。这其中关键部分是这个 signal 属性，它是AbortSignal对象的一个实例，这个对象有两个属性，一个是 aborted，布尔值，用于表明当前的请求是否处于中止状态；另一个是 reason，在前者为 true 的情况下，用于表示中止的原因。这两个属性都是只读的，也就是说，我们无法直接对属性进行赋值，只能通过调用 abort 方法来改变signal.aborted的值，再通过判断此值来决定是否终止请求。
何处/何时中止请求 了解 axios 在何处可能会中止请求，对于我们使用这个功能有很大的帮助。首先看一下 axios 如何使用这个 API，由于官方文档可能并未实时更新，我们可以在根目录下的index.d.ts文件中找到关于 signal 的配置项，可以看出，这和在 fetch API 中的使用是一样的。那么在 axios 内部是怎样的逻辑呢？通过前面几篇的了解，可以知道 axios 的请求发送过程大致可以分为以下几个部分：
请求拦截器 request InterceptorManager 发送请求 dispatchRequest 请求适配器 adaptor 请求发送 send / request 请求响应 response 响应格式化 transform 响应拦截器 response InterceptorManager 上一篇分析了 axios 的拦截器，这个模块实际上是对请求的配置进行处理，并不会涉及真正的请求发送，所以自然也就没有中止请求一说。而在拦截器之后，将会进入到dispatchRequest函数内，函数一开头，我们可以看到一个名为throwIfCancellationRequested的函数，其函数体非常简单，就是判断配置中是否存在 signal 属性，如果存在并且 signal 的 aborted 属性是 true 那么就会抛出一个请求取消的错误。也就是说，如果你在请求拦截器处理完成之前取消请求，那么请求会在进入 dispatchRequest 函数的第一时间中止请求的发送。...</p></div><footer class=entry-footer><span title='2022-06-02 21:03:44 +0800 CST'>六月 2, 2022</span>&nbsp;·&nbsp;eyebrowkang</footer><a class=entry-link aria-label="post link to axios源码解析（三）" href=https://tech.eyebrowkang.com/posts/2022-06-02-axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%89/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://tech.eyebrowkang.com/posts/page/2/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://tech.eyebrowkang.com>Share Some Tech</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>